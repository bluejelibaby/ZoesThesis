<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">





<!-- ViewVC :: http://www.viewvc.org/ -->

<title>[CMSSW] View of /UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc</title>
<meta name="generator" content="ViewVC 1.0.4">
<link rel="stylesheet" href="JadPlottingOps.cc_files/styles.css" type="text/css">

</head><body>
<div class="vc_navheader">

<form method="get" action="/cgi-bin/cmssw.cgi/">

<table style="padding: 0.1em;">
<tbody><tr>
<td>
<strong>

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/">

[CMSSW]</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/">

UserCode</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/">

ICFSusy</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/">

AnalysisV2</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/">

WPol</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/">

src</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/">

common</a>
/

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc?view=log">

JadPlottingOps.cc</a>


</strong>

</td>
<td style="text-align: right;">


<strong>Repository:</strong>
<select name="root" onchange="submit()">


<option value="*viewroots*">Repository Listing</option>










<optgroup label="CVS Repositories"><option selected="selected">CMSSW</option></optgroup>


</select>
<input value="Go" type="submit">

</td>
</tr>
</tbody></table>

</form>

</div>
<div style="padding: 5px; float: right;"><a href="http://www.viewvc.org/"><img src="JadPlottingOps.cc_files/logo.png" alt="ViewVC logotype" height="48" width="128"></a></div>
<h1>View of /UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc</h1>

<p style="margin: 0pt;">

<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/"><img src="JadPlottingOps.cc_files/back_small.png" alt="Parent Directory" height="16" width="16"> Parent Directory</a>

| <a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc?view=log"><img src="JadPlottingOps.cc_files/log.png" alt="Revision Log" height="16" width="16"> Revision Log</a>


| <a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc?view=graph"><img src="JadPlottingOps.cc_files/cvsgraph_16x16.png" alt="View Revision Graph" height="16" width="16"> Revision Graph</a>



</p>

<hr>
<div class="vc_summary">
Revision <strong>1.5</strong> -
(<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc?revision=1.5"><strong>download</strong></a>)

(<a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/UserCode/ICFSusy/AnalysisV2/WPol/src/common/JadPlottingOps.cc?annotate=1.5"><strong>annotate</strong></a>)

<br><em>Tue Mar  2 21:24:56 2010 UTC</em>
(2 weeks ago)
by <em>jad</em>


<br>Branch: <strong>MAIN</strong>


<br>CVS Tags: <strong>WPol_020310, HEAD</strong>




<br>Changes since <strong>1.4: +545 -226 lines</strong>





<pre class="vc_log">Made RECOPolPlots more flexible/safe, factored out Collins-Soper frame boost, general tidy-up
</pre>

</div>
<div id="vc_markup"><pre><pre><i><font color="#b22222">/*! \file JadPlottingOps.cc
 * \brief Source code for the Monte Carlo-based plotting operations.
 */</font></i>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"JadPlottingOps.hh"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"reweightingFactors.hh"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"GenObject.hh"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"GenMatrixBin.hh"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"Lepton.hh"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"EventData.hh"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"Math/VectorUtil.h"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"TVector3.h"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"TLorentzVector.h"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>"TH1.h"</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>&lt;sstream&gt;</b></font><b></b>
#<b><font color="#5f9ea0">include</font></b> <font color="#bc8f8f"><b>&lt;iostream&gt;</b></font><b></b>

namespace Operation {

  TLorentzVector TLVConvert(<font color="#228b22"><b>const</b></font><b></b> LorentzV * particle) {
    TLorentzVector TLVparticle(particle-&gt;Px(), particle-&gt;Py(), particle-&gt;Pz(), particle-&gt;E());
    <b><font color="#a020f0">return</font></b> TLVparticle;
  }

  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// CS Frame Transformation Function
</font></i>  <i><font color="#b22222">//====================================
</font></i>  TLorentzVector CSTransform(<font color="#228b22"><b>const</b></font><b></b> TLorentzVector &amp; input_particle, <font color="#228b22"><b>const</b></font><b></b> TLorentzVector &amp; w_vector) {

    <font color="#228b22"><b>bool</b></font><b></b> printinfo = false; <i><font color="#b22222">//change to select option to print out stuff
</font></i>
    TLorentzVector proton1;
    TLorentzVector proton2;
    TLorentzVector w(w_vector);
    <i><font color="#b22222">//TLorentzVector muon;
</font></i>    <i><font color="#b22222">//TLorentzVector neutrino;
</font></i>    TLorentzVector output_particle(input_particle);

    TVector3 boostvec;

    <i><font color="#b22222">//initialise our 3.5TeV protons!
</font></i>    proton1.SetXYZM(0.0,0.0,3500.0,1.0);
    proton2.SetXYZM(0.0,0.0,-3500.0,1.0);
    <i><font color="#b22222">//w = w_vector;
</font></i>    <i><font color="#b22222">//output_particle = input_particle;
</font></i>
    boostvec = w.BoostVector();
    proton1.Boost(-boostvec);
    proton2.Boost(-boostvec);
    output_particle.Boost(-boostvec);
    <i><font color="#b22222">//muon.Boost(-boostvec);
</font></i>    <i><font color="#b22222">//neutrino.Boost(-boostvec);
</font></i>
    <b><font color="#a020f0">if</font></b>(printinfo) {
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"After boost into W rest-frame"</b></font><b></b> &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"W boson: Px= "</b></font><b></b> &lt;&lt; w.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; w.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; w.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Proton1: Px= "</b></font><b></b> &lt;&lt; proton1.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; proton1.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; proton1.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Proton2: Px= "</b></font><b></b> &lt;&lt; proton2.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; proton2.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; proton2.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between protons in W-rest frame = "</b></font><b></b> &lt;&lt; proton1.Angle(proton2.Vect()) &lt;&lt; std::endl;
    }

    TVector3 normal_plane1;
    TVector3 normal_plane2;
    <i><font color="#b22222">//this is just the cross product between the two proton vector which gives a vector normal to both of them (but not a unit vector)
</font></i>    <font color="#228b22"><b>double</b></font><b></b> xp_i = (proton1.Py() * proton2.Pz()) - (proton1.Pz() * proton2.Py());
    <font color="#228b22"><b>double</b></font><b></b> xp_j = (proton1.Pz() * proton2.Px()) - (proton1.Px() * proton2.Pz());
    <font color="#228b22"><b>double</b></font><b></b> xp_k = (proton1.Px() * proton2.Py()) - (proton1.Py() * proton2.Px());
    normal_plane1.SetXYZ(xp_i, xp_j, xp_k);
    normal_plane2.SetXYZ(0.0,1.0,0.0);
    <i><font color="#b22222">//use the vector normal to the x-z plane and the vec normal to both protons to find the rotation angle
</font></i>    <font color="#228b22"><b>double</b></font><b></b> rotation_angle = TMath::Pi() - normal_plane1.Angle(normal_plane2);

    <b><font color="#a020f0">if</font></b>(printinfo) {
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between two planes: "</b></font><b></b> &lt;&lt; rotation_angle &lt;&lt; std::endl;
    }
    <i><font color="#b22222">//now rotate the boosted protons about the line of intersection (TVector3) of the two planes by the angle above
</font></i>    TVector3 rotation_axis;
    <i><font color="#b22222">//this is the cross product of the two normal vectors, which gives a vector parallel to the line of intersection
</font></i>    <font color="#228b22"><b>double</b></font><b></b> xp2_i = -1.0 * normal_plane1.Pz();
    <font color="#228b22"><b>double</b></font><b></b> xp2_j = 0.0;
    <font color="#228b22"><b>double</b></font><b></b> xp2_k = normal_plane1.Px();
    rotation_axis.SetXYZ(xp2_i, xp2_j, xp2_k);

    <i><font color="#b22222">//perform the rotation by the angle
</font></i>    proton1.Rotate(-rotation_angle, rotation_axis);
    proton2.Rotate(-rotation_angle, rotation_axis);
    output_particle.Rotate(-rotation_angle, rotation_axis);
    <i><font color="#b22222">//muon.Rotate(-rotation_angle, rotation_axis);
</font></i>    <i><font color="#b22222">//neutrino.Rotate(-rotation_angle, rotation_axis);
</font></i>
    <b><font color="#a020f0">if</font></b>(printinfo) {
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"After rotation"</b></font><b></b> &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"W boson: Px= "</b></font><b></b> &lt;&lt; w.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; w.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; w.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Proton1: Px= "</b></font><b></b> &lt;&lt; proton1.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; proton1.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; proton1.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Proton2: Px= "</b></font><b></b> &lt;&lt; proton2.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; proton2.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; proton2.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between protons in W-rest frame = "</b></font><b></b> &lt;&lt; proton1.Angle(proton2.Vect()) &lt;&lt; std::endl;
    }

    <i><font color="#b22222">//now need to rotate again so that the z-axis bisects (i.e. cuts equally in two) the angle between the proton and the negative proton moving against z-dir originally
</font></i>    <i><font color="#b22222">//start by calculating the angle between each vector and the z-axis
</font></i>    TVector3 zaxis;
    zaxis.SetXYZ(0.0, 0.0, 1.0);
    <b><font color="#a020f0">if</font></b>(printinfo) {
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between proton1 and z-axis = "</b></font><b></b> &lt;&lt; proton1.Angle(zaxis) &lt;&lt; std::endl;
      <i><font color="#b22222">//std::cout &lt;&lt; "Angle between proton2 and z-axis = " &lt;&lt; proton2.Angle(zaxis) &lt;&lt; std::endl;
</font></i>      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between -proton2 and z-axis = "</b></font><b></b> &lt;&lt; (-1.0*proton2).Angle(zaxis) &lt;&lt; std::endl;
    }

    <i><font color="#b22222">//then rotate around y, the negative average of the values
</font></i>    <i><font color="#b22222">//the reason there is a minus sign is because in general, the z-axis will already be between the two vectors and the Angle() method does not return a sign...
</font></i>    <font color="#228b22"><b>double</b></font><b></b> rotation_angle2 = ((-1.0*proton2).Angle(zaxis) - proton1.Angle(zaxis)) / 2.0;
    proton1.RotateY(-rotation_angle2);
    proton2.RotateY(-rotation_angle2);
    output_particle.RotateY(-rotation_angle2);
    <i><font color="#b22222">//muon.RotateY(-rotation_angle2);
</font></i>    <i><font color="#b22222">//neutrino.RotateY(-rotation_angle2);
</font></i>    
    <b><font color="#a020f0">if</font></b>(printinfo) {
      std::cout &lt;&lt; rotation_angle2 &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"In Collins-Soper Frame"</b></font><b></b> &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"W boson: Px= "</b></font><b></b> &lt;&lt; w.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; w.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; w.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Proton1: Px= "</b></font><b></b> &lt;&lt; proton1.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; proton1.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; proton1.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Proton2: Px= "</b></font><b></b> &lt;&lt; proton2.Px() &lt;&lt; <font color="#bc8f8f"><b>" Py= "</b></font><b></b> &lt;&lt; proton2.Py() &lt;&lt; <font color="#bc8f8f"><b>" Pz= "</b></font><b></b> &lt;&lt; proton2.Pz() &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between protons = "</b></font><b></b> &lt;&lt; proton1.Angle(proton2.Vect()) &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between proton1 and z-axis = "</b></font><b></b> &lt;&lt; proton1.Angle(zaxis) &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"Angle between -proton2 and z-axis = "</b></font><b></b> &lt;&lt; (-1.0*proton2).Angle(zaxis) &lt;&lt; std::endl;
      std::cout &lt;&lt; <font color="#bc8f8f"><b>"----- End of event -----"</b></font><b></b> &lt;&lt; std::endl &lt;&lt; std::endl;    
    }
    <b><font color="#a020f0">return</font></b> output_particle;
  }
  


  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// Boost Calculation Function 
</font></i>  <i><font color="#b22222">//====================================
</font></i>
  jSolutionsW FindBoost(<font color="#228b22"><b>const</b></font><b></b> TLorentzVector &amp; jMuon, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; jVWPx, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; jVWPy, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; jVWPz, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>bool</b></font><b></b> &amp; cheat=true, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>bool</b></font><b></b> &amp; approximate=true, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; jVWM=80.4) {
  <i><font color="#b22222">//jSolutionsW FindBoost(const LorentzV &amp; jMuonV, const double &amp; jVWPx, const double &amp; jVWPy, const double &amp; jVWPz, const bool &amp; cheat=true, const bool &amp; approximate=true, const double &amp; jVWM=80.4) {
</font></i>    <i><font color="#b22222">//by having the function in this form, you can slot various combinations for the (px,py,pz) components
</font></i>    <i><font color="#b22222">//the cheat variable allows you to choose if you want sol1/sol2 or rightsol/wrongsol - for this you need to pass jVWPz of the real W
</font></i>    <i><font color="#b22222">//the approximate variable allows you to choose if you want the approximation using mw=80.4, or the true generator boost back to the W rest frame - must supply jVWM
</font></i>    <i><font color="#b22222">//the cheat variable is redundant if the approximate variable is set to false
</font></i>
    <i><font color="#b22222">//you can follow this calculation if you start from the four-vector argument P_W = P_Mu + P_MuNu and rearrange so P_MuNu is on its own.
</font></i>    <i><font color="#b22222">//then square both sides, taking mass_neutrino = 0. Also the dot product of two threevectors is p1xp2x+p1yp2y+p1zp2z and not p1 p2 cos(theta_12)
</font></i>    <i><font color="#b22222">//since theta_12 relies on knowing the pz components...
</font></i>

    <i><font color="#b22222">//To change from TLorentzVector to ROOT::Math::LorentzVector&lt;ROOT::Math::PxPyPzE4D&lt;double&gt; &gt; the following mod must be made to preserve the code below
</font></i>    <i><font color="#b22222">//TLorentzVector jMuon(jMuonV.x(),jMuonV.y(),jMuonV.z(),jMuonV.t());
</font></i>
    jSolutionsW results;
    TLorentzVector jRestMu, jTemp4V;
    TVector3 jTempBV;
    <font color="#228b22"><b>double</b></font><b></b> CosThetaStarSol1, CosThetaStarSol2;

    <b><font color="#a020f0">if</font></b>(approximate) {
      <font color="#228b22"><b>double</b></font><b></b> jVWPt2 = ((jVWPx * jVWPx) + (jVWPy * jVWPy)); <i><font color="#b22222">//this is the Pt squared
</font></i>      <font color="#228b22"><b>double</b></font><b></b> delta = ((80.4*80.4)+(0.106*0.106))/2.0 + (jVWPx * jMuon.Px()) + (jVWPy * jMuon.Py());
      <font color="#228b22"><b>double</b></font><b></b> alpha = (jMuon.E() * jMuon.E()) - (jMuon.Pz() * jMuon.Pz());
      <font color="#228b22"><b>double</b></font><b></b> beta = -2.0 * delta * jMuon.Pz();
      <font color="#228b22"><b>double</b></font><b></b> gamma = (jMuon.E() * jMuon.E()) * (jVWPt2 + (80.4*80.4)) - (delta * delta);
      <font color="#228b22"><b>double</b></font><b></b> discarg = (beta*beta) - (4*alpha*gamma);

      <b><font color="#a020f0">if</font></b>(discarg &gt; 0) {
	<font color="#228b22"><b>double</b></font><b></b> discriminant = sqrt(discarg);
	<font color="#228b22"><b>double</b></font><b></b> sol1 = (-1.0*beta + discriminant) / (2*alpha);
	<font color="#228b22"><b>double</b></font><b></b> sol2 = (-1.0*beta - discriminant) / (2*alpha);

	results.realSolutions = true; <i><font color="#b22222">//since the discriminant is &gt;0, we get real solutions
</font></i>
	jRestMu = jMuon;
	jTemp4V.SetXYZM(jVWPx,jVWPy,sol1,80.4);
	jTempBV = jTemp4V.BoostVector();
	jRestMu.Boost(-jTempBV);
	CosThetaStarSol1 = cos(ROOT::Math::VectorUtil::Angle(jRestMu,jTemp4V));

	jRestMu = jMuon;
	jTemp4V.SetXYZM(jVWPx,jVWPy,sol2,80.4);
	jTempBV = jTemp4V.BoostVector();
	jRestMu.Boost(-jTempBV);
	CosThetaStarSol2 = cos(ROOT::Math::VectorUtil::Angle(jRestMu,jTemp4V));

	<b><font color="#a020f0">if</font></b>(cheat) {
	  <b><font color="#a020f0">if</font></b>(fabs(sol1 - jVWPz) &lt; fabs(sol2 - jVWPz)) {
	    results.rightSol = CosThetaStarSol1;
	    results.wrongSol = CosThetaStarSol2;
	  } <b><font color="#a020f0">else</font></b> {
	    results.rightSol = CosThetaStarSol2;
	    results.wrongSol = CosThetaStarSol1;
	  }
	  results.sol1 = 0.0;
	  results.sol2 = 0.0;
	  <b><font color="#a020f0">return</font></b> results;
	} <b><font color="#a020f0">else</font></b> {
	  results.rightSol = 0.0;
	  results.wrongSol = 0.0;
	  results.sol1 = CosThetaStarSol1;
	  results.sol2 = CosThetaStarSol2;
	  <b><font color="#a020f0">return</font></b> results;
	}
      } <b><font color="#a020f0">else</font></b> {
	results.realSolutions = false;
	results.rightSol = 0.0;
	results.wrongSol = 0.0;
	results.sol1 = 0.0;
	results.sol2 = 0.0;
	<b><font color="#a020f0">return</font></b> results;
      }
    } <b><font color="#a020f0">else</font></b> {
      jRestMu = jMuon;
      jTemp4V.SetXYZM(jVWPx,jVWPy,jVWPz,jVWM);
      jTempBV = jTemp4V.BoostVector();
      jRestMu.Boost(-jTempBV);
      CosThetaStarSol1 = cos(ROOT::Math::VectorUtil::Angle(jRestMu,jTemp4V));

      results.realSolutions = true;
      results.rightSol = CosThetaStarSol1;
      results.wrongSol = 0.0;
      results.sol1 = 0.0;
      results.sol2 = 0.0;
      <b><font color="#a020f0">return</font></b> results;
    }

  }


  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// MCWPlots implementation 
</font></i>  <i><font color="#b22222">//====================================
</font></i>
  <i><font color="#b22222">//a brief note about this class - it has evolved quite a lot
</font></i>  <i><font color="#b22222">//note the replacement by eta with rapidity e.g. and also it used to be just muons (most histograms are still artefacts of this) but now has been generalised to leptons
</font></i>  <i><font color="#b22222">//to get the 100% left handed case etc, reweight acording to the factors in the methods below (see the standalone macro for how this is filled)
</font></i><i><font color="#b22222">/*
  std::vector&lt;double&gt; &amp; MCWPlots::LHM() {
    static std::vector&lt;double&gt; lhm_coeff = init_lhm();    
    return lhm_coeff;
  }

  std::vector&lt;double&gt; &amp; MCWPlots::LHP() {
    static std::vector&lt;double&gt; lhp_coeff = init_lhp();    
    return lhp_coeff;
  }
*/</font></i>

  std::vector&lt; std::vector&lt;jFitParameters&gt; &gt; &amp; GetFitParameters() {
    <font color="#228b22"><b>static</b></font><b></b> std::vector&lt; std::vector&lt;jFitParameters&gt; &gt; binned_fit_params = init_fit_params();
    <b><font color="#a020f0">return</font></b> binned_fit_params;
  }

  <font color="#228b22"><b>double</b></font><b></b> BinFraction(<font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; alpha, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; beta, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; gamma, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> &amp; bin) {
    <i><font color="#b22222">//the format i'm using for the fit function is as follows:
</font></i>    <i><font color="#b22222">//alpha * (1-x)^2 +
</font></i>    <i><font color="#b22222">//beta * (1+x)^2 +
</font></i>    <i><font color="#b22222">//gamma * (1-x^2)
</font></i>
    <i><font color="#b22222">//for all our plots, we have a defined bin width for the gen level cos(theta*) plots
</font></i>    <font color="#228b22"><b>double</b></font><b></b> bin_width = 0.01;
    <i><font color="#b22222">//bin 0 by our definition is the bin between -1.00 and -0.99 etc
</font></i>    <i><font color="#b22222">//subtract 1.0 below to go back to region cos(theta*) = (-1.0, 1.0)
</font></i>    <font color="#228b22"><b>double</b></font><b></b> bin_lowedge = <font color="#228b22"><b>double</b></font><b></b>(bin)*bin_width - 1.0;

    <i><font color="#b22222">//now make some easy to use variable names for the calculation below
</font></i>    <font color="#228b22"><b>double</b></font><b></b> a = bin_lowedge;
    <font color="#228b22"><b>double</b></font><b></b> b = bin_lowedge + bin_width;

    <font color="#228b22"><b>double</b></font><b></b> bin_integral = IntegralValue(a,b, alpha, beta, gamma);
    <i><font color="#b22222">//std::cout &lt;&lt; "bin_integral = "&lt;&lt; bin_integral &lt;&lt; std::endl;
</font></i>    <font color="#228b22"><b>double</b></font><b></b> total_integral = IntegralValue(-1.0,1.0, alpha, beta, gamma); <i><font color="#b22222">//test for 0
</font></i>    <i><font color="#b22222">//std::cout &lt;&lt; "total_integral = "&lt;&lt; total_integral &lt;&lt; std::endl;
</font></i>    <font color="#228b22"><b>double</b></font><b></b> fraction = bin_integral / total_integral;

    <b><font color="#a020f0">return</font></b> fraction;

  }

  <font color="#228b22"><b>double</b></font><b></b> IntegralValue(<font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; a, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; b, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; alpha, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; beta, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; gamma) {
    <i><font color="#b22222">//below is what you get if you integrate by hand the three components and evaluate them between b and a
</font></i>    <font color="#228b22"><b>double</b></font><b></b> alpha_part = 1.0/4.0 * ((b-a) - ((b*b)-(a*a)) + ((1.0/3.0)*((b*b*b) - (a*a*a))));
    <font color="#228b22"><b>double</b></font><b></b> beta_part = 1.0/4.0 * ((b-a) + ((b*b)-(a*a)) + ((1.0/3.0)*((b*b*b) - (a*a*a))));
    <font color="#228b22"><b>double</b></font><b></b> gamma_part = 1.0/2.0 * ((b-a) - (1.0/3.0)*((b*b*b) - (a*a*a)));
    <font color="#228b22"><b>double</b></font><b></b> total_integral = ((alpha*alpha_part) + (beta*beta_part) + (gamma*gamma_part));
    <b><font color="#a020f0">return</font></b> total_integral;
  }

  <font color="#228b22"><b>double</b></font><b></b> CorrFactor(<font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; PTW, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>double</b></font><b></b> &amp; YW, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> &amp; bin, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>bool</b></font><b></b> &amp; poscharge, <font color="#228b22"><b>const</b></font><b></b> <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> &amp; norm_type) {
    
    <b><font color="#a020f0">if</font></b>(norm_type &gt; 2) std::cout &lt;&lt; <font color="#bc8f8f"><b>"Why is norm_type greater than 2? There are only 3 polarisation modes!"</b></font><b></b> &lt;&lt; std::endl;
    <font color="#228b22"><b>double</b></font><b></b> alpha=0.0, beta=0.0, gamma=0.0;
    <i><font color="#b22222">//initialise the (alpha,beta,gamma) parameters for the different scenarios - namely charge(-,+) with norm_type (LH=0, RH=1, LO=2)
</font></i>    <b><font color="#a020f0">if</font></b>(poscharge) {
      <b><font color="#a020f0">if</font></b>(norm_type == 0) {alpha=1.0;beta=0.0;gamma=0.0;}
      <b><font color="#a020f0">if</font></b>(norm_type == 1) {alpha=0.0;beta=1.0;gamma=0.0;}
      <b><font color="#a020f0">if</font></b>(norm_type == 2) {alpha=0.0;beta=0.0;gamma=1.0;}
    }<b><font color="#a020f0">else</font></b>{
      <b><font color="#a020f0">if</font></b>(norm_type == 0) {alpha=0.0;beta=1.0;gamma=0.0;}
      <b><font color="#a020f0">if</font></b>(norm_type == 1) {alpha=1.0;beta=0.0;gamma=0.0;}
      <b><font color="#a020f0">if</font></b>(norm_type == 2) {alpha=0.0;beta=0.0;gamma=1.0;}
    }

    <font color="#228b22"><b>double</b></font><b></b> norm_type_ratio = BinFraction(alpha, beta, gamma, bin);
    <i><font color="#b22222">//std::cout &lt;&lt; "norm_type_ratio = " &lt;&lt; norm_type_ratio &lt;&lt; std::endl;
</font></i>
    <i><font color="#b22222">//now here is where the lookup for the appropriate alpha,beta,gamma factors happens according to W Pt and Y bins
</font></i>    <i><font color="#b22222">//revise this quanta stuff as appropriate - the bins we are using are:
</font></i>    <i><font color="#b22222">//W Pt, 0-50, 50-100, 100+
</font></i>    <i><font color="#b22222">//W |Y|, 0-0.5, 0.5-1.0, 1.0-1.5, 1.5-2.0, 2.0-2.5, 2.5-3.0, 3.0+ 
</font></i>    <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> PTWbin = 0;
    <b><font color="#a020f0">if</font></b>(PTW &lt;= 50.0) PTWbin = 0;
    <b><font color="#a020f0">if</font></b>(PTW &lt;= 100.0 &amp;&amp; PTW &gt; 50.0) PTWbin = 1;
    <b><font color="#a020f0">if</font></b>(PTW &gt; 100.0) PTWbin = 2;

    <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> YWbin = 0;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &lt;= 0.5) YWbin=0;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &lt;= 1.0 &amp;&amp; fabs(YW) &gt; 0.5) YWbin=1;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &lt;= 1.5 &amp;&amp; fabs(YW) &gt; 1.0) YWbin=2;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &lt;= 2.0 &amp;&amp; fabs(YW) &gt; 1.5) YWbin=3;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &lt;= 2.5 &amp;&amp; fabs(YW) &gt; 2.0) YWbin=4;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &lt;= 3.0 &amp;&amp; fabs(YW) &gt; 2.5) YWbin=5;
    <b><font color="#a020f0">if</font></b>(fabs(YW) &gt; 3.0) YWbin=6;

    <b><font color="#a020f0">if</font></b>(poscharge) {
      alpha = GetFitParameters().at(PTWbin).at(YWbin).alpha_plus;
      beta = GetFitParameters().at(PTWbin).at(YWbin).beta_plus;
      gamma = GetFitParameters().at(PTWbin).at(YWbin).gamma_plus;
    }<b><font color="#a020f0">else</font></b>{
      alpha = GetFitParameters().at(PTWbin).at(YWbin).alpha_minus;
      beta = GetFitParameters().at(PTWbin).at(YWbin).beta_minus;
      gamma = GetFitParameters().at(PTWbin).at(YWbin).gamma_minus;	
    }
    <font color="#228b22"><b>double</b></font><b></b> curr_type_ratio = BinFraction(alpha, beta, gamma, bin); <i><font color="#b22222">//test for 0
</font></i>    <i><font color="#b22222">//std::cout &lt;&lt; "curr_type_ratio = " &lt;&lt; curr_type_ratio &lt;&lt; std::endl;
</font></i>
    <font color="#228b22"><b>double</b></font><b></b> corr_factor = norm_type_ratio/curr_type_ratio;

    <b><font color="#a020f0">return</font></b> corr_factor;
  }

  MCWPlots::MCWPlots(<font color="#228b22"><b>const</b></font><b></b> std::string &amp; folderName) :
    mFolderName(folderName) {}
   
  MCWPlots::~MCWPlots() {}

  <font color="#228b22"><b>void</b></font><b></b> MCWPlots::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  <font color="#228b22"><b>void</b></font><b></b> MCWPlots::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    MC_WMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WMultiplicity"</b></font><b></b>, <font color="#bc8f8f"><b>";genW Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_MuonMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonMultiplicity"</b></font><b></b>, <font color="#bc8f8f"><b>";genMuon Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_MuonNuMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuMultiplicity"</b></font><b></b>, <font color="#bc8f8f"><b>";genMuonNu Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_JetMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetMultiplicity"</b></font><b></b>,<font color="#bc8f8f"><b>";genJet Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_JetMultiplicityAll = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetMultiplicityAll"</b></font><b></b>,<font color="#bc8f8f"><b>";All genJet Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_JetPt = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetPt"</b></font><b></b>,<font color="#bc8f8f"><b>";genJet P_{T} distribution;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_JetEta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetEta"</b></font><b></b>,<font color="#bc8f8f"><b>";genJet #eta distribution;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_JetPtAll = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetPtAll"</b></font><b></b>,<font color="#bc8f8f"><b>";All genJet P_{T} distribution;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_JetEtaAll = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetEtaAll"</b></font><b></b>,<font color="#bc8f8f"><b>";All genJet #eta distribution;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_JetMHT = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetMHT"</b></font><b></b>,<font color="#bc8f8f"><b>";genJet MHT magnitude;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_JetMHT2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_JetMHT2"</b></font><b></b>,<font color="#bc8f8f"><b>";genJet MHT2 magnitude;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_VirtualWMass = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_VirtualWMass"</b></font><b></b>,<font color="#bc8f8f"><b>";Virtual W Mass;Events / 100 pb^{-1}"</b></font><b></b>,400,59.5,99.5);
    MC_VirtualWMassRe = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_VirtualWMassRe"</b></font><b></b>,<font color="#bc8f8f"><b>";Virtual W Mass for real solutions to pz;Events / 100 pb^{-1}"</b></font><b></b>,400,59.5,99.5);
    MC_VirtualWMassIm = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_VirtualWMassIm"</b></font><b></b>,<font color="#bc8f8f"><b>";Virtual W Mass for imaginary solutions to pz;Events / 100 pb^{-1}"</b></font><b></b>,400,59.5,99.5);
    MC_WPT = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPT"</b></font><b></b>, <font color="#bc8f8f"><b>";genW P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_WEta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WEta"</b></font><b></b>, <font color="#bc8f8f"><b>";genW #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.05,4.95);
    MC_WY = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WY"</b></font><b></b>, <font color="#bc8f8f"><b>";genW Y;Events / 100 pb^{-1}"</b></font><b></b>,5000,-25.05,24.95);
    MC_WPtPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPtPlus"</b></font><b></b>, <font color="#bc8f8f"><b>";genW^{+} P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_WPtMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPtMinus"</b></font><b></b>, <font color="#bc8f8f"><b>";genW^{-} P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_WEtaPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WEtaPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";genW^{+} #eta;Events / 100 pb^{-1}"</b></font><b></b>, 250,-0.5,24.5);
    MC_WYPlus= <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WYPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";genW^{+} |Y|;Events / 100 pb^{-1}"</b></font><b></b>, 50,-0.05,4.95);
    MC_WEtaMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WEtaMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";genW^{-} #eta;Events / 100 pb^{-1}"</b></font><b></b>, 250,-0.5,24.5);
    MC_WYMinus= <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WYMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";genW^{-} |Y|;Events / 100 pb^{-1}"</b></font><b></b>, 50,-0.05,4.95);
    MC_MHTGenJetsWPtDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MHTGenJetsWPtDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MH_{T}, W P_{T}) / genW P_{T};Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MHTAllGenJetsWPtDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MHTAllGenJetsWPtDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MH_{T}, W P_{T}) / genW P_{T};Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MHT2GenJetsWPtDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MHT2GenJetsWPtDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MH_{T}2, W P_{T}) / genW P_{T};Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonPt = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPt"</b></font><b></b>, <font color="#bc8f8f"><b>";genW to #mu P_{T} ;Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_MuonEta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEta"</b></font><b></b>,<font color="#bc8f8f"><b>";genW to #mu #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonEtaAbs = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaAbs"</b></font><b></b>,<font color="#bc8f8f"><b>";genW to #mu |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,50,-0.5,4.5);
    MC_MuonNuPt = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPt"</b></font><b></b>, <font color="#bc8f8f"><b>";genW to #mu #nu P_{T} ;Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_MuonNuEta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEta"</b></font><b></b>,<font color="#bc8f8f"><b>";genW to #mu #nu #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonNuEtaAbs = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaAbs"</b></font><b></b>,<font color="#bc8f8f"><b>";genW to #mu #nu |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,50,-0.5,4.5);

    MC_MuonPtCut1 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtCut1"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu P_{T}, p_{T} &gt; 10 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonPtCut2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtCut2"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu P_{T}, p_{T} &gt; 20 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonEtaCut1 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaCut1"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #eta, p_{T} &gt; 10 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonEtaCut2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaCut2"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #eta, p_{T} &gt; 20 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonNuPtCut1 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtCut1"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #nu P_{T}, p_{T} &gt; 10 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuPtCut2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtCut2"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #nu P_{T}, p_{T} &gt; 20 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuEtaCut1 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaCut1"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #nu #eta, p_{T} &gt; 10 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonNuEtaCut2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaCut2"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #nu #eta, p_{T} &gt; 20 GeV |#eta| &lt; 2.1;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonNuPtCut1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtCut1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{+} #nu p_{T} cut1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonPtCut1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtCut1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{+} p_{T} cut1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuPtCut1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtCut1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{-} #nu p_{T} cut1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonPtCut1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtCut1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{-} p_{T} cut1;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuPtCut2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtCut2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{+} #nu p_{T} cut2;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonPtCut2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtCut2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{+} p_{T} cut2;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuPtCut2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtCut2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{-} #nu p_{T} cut2;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonPtCut2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtCut2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{-} p_{T} cut2;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);

    MC_MuonPtPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^+ P_{T};Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuPtPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^+ #nu P_{T};Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonEtaPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^+ #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonEtaAbsPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaAbsPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^+ |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,50,-0.5,4.5);
    MC_MuonNuEtaPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^+ #nu #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonNuEtaAbsPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaAbsPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^+ #nu |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,50,-0.5,4.5);
    MC_ICVarPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlus_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlus_LH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} LH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlus_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlus_RH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} RH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlus_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlus_LO"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} LO;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlusMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlusMuonAcc"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlusMuonAcc_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlusMuonAcc_LH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} LH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlusMuonAcc_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlusMuonAcc_RH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} RH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarPlusMuonAcc_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlusMuonAcc_LO"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} LO;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_MuonPtMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPtMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^- P_{T};Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonNuPtMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuPtMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^- #nu P_{T};Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_MuonEtaMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^- #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonEtaAbsMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEtaAbsMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^- |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,50,-0.5,4.5);
    MC_MuonNuEtaMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^- #nu #eta;Events / 100 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_MuonNuEtaAbsMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonNuEtaAbsMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^- #nu |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,50,-0.5,4.5);
    MC_ICVarMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^-;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinus_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinus_LH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} LH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinus_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinus_RH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} RH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinus_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinus_LO"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} LO;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinusMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinusMuonAcc"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^-;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinusMuonAcc_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinusMuonAcc_LH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} LH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinusMuonAcc_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinusMuonAcc_RH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} RH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinusMuonAcc_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinusMuonAcc_LO"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} LO;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);


    MC_WPlusPzMatching = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPlusPzMatching"</b></font><b></b>,<font color="#bc8f8f"><b>";False/True;Events"</b></font><b></b>,2,-0.5,1.5);
    MC_WMinusPzMatching = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WMinusPzMatching"</b></font><b></b>,<font color="#bc8f8f"><b>";False/True;Events"</b></font><b></b>,2,-0.5,1.5);
    MC_CosThetaStar1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar2Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar2Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar3Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar3Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar3Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar3Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Minus_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Minus_LH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} LH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Minus_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Minus_RH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} RH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Minus_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Minus_LO"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} LO ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Plus_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Plus_LH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} LH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Plus_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Plus_RH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} RH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Plus_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Plus_LO"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} LO ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1PlusMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1PlusMuonAcc"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1MinusMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1MinusMuonAcc"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1MinusMuonAcc_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1MinusMuonAcc_LH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} LH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1MinusMuonAcc_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1MinusMuonAcc_RH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} RH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1MinusMuonAcc_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1MinusMuonAcc_LO"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} LO ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1PlusMuonAcc_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1PlusMuonAcc_LH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} LH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1PlusMuonAcc_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1PlusMuonAcc_RH"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} RH ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1PlusMuonAcc_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1PlusMuonAcc_LO"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} LO ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);

    <i><font color="#b22222">//for W Eta bins
</font></i>    MC_CosThetaStar1RightPzWEtaBin1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} #eta &lt; 0.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} #eta &lt; 0.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 0.5 &lt; #eta &lt; 1.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 0.5 &lt; #eta &lt; 1.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin3Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin3Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 1.0 &lt; #eta &lt; 1.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin3Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin3Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 1.0 &lt; #eta &lt; 1.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin4Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin4Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 1.5 &lt; #eta &lt; 2.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin4Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin4Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 1.5 &lt; #eta &lt; 2.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin5Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin5Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 2.0 &lt; #eta &lt; 2.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin5Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin5Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 2.0 &lt; #eta &lt; 2.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin6Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin6Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 2.5 &lt; #eta &lt; 3.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin6Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin6Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 2.5 &lt; #eta &lt; 3.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin7Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin7Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 3.0 &lt; #eta &lt; 3.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin7Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin7Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 3.0 &lt; #eta &lt; 3.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin8Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin8Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 3.5 &lt; #eta &lt; 4.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin8Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin8Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 3.5 &lt; #eta &lt; 4.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin9Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin9Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 4.0 &lt; #eta &lt; 4.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin9Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin9Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 4.0 &lt; #eta &lt; 4.5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin10Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin10Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 4.5 &lt; #eta &lt; 5.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin10Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin10Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 4.5 &lt; #eta &lt; 5.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin11Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin11Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} #eta &gt; 5.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin11Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWEtaBin11Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} #eta &gt; 5.0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    <i><font color="#b22222">//for W Pt bins
</font></i>    MC_CosThetaStar1RightPzWPtBin1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 100 &lt; p_{T} &lt; 200 ;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 100 &lt; p_{T} &lt; 200;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 200 &lt; p_{T} &lt; 300;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 200 &lt; p_{T} &lt; 300;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin3Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin3Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 300 &lt; p_{T} &lt; 400;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin3Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin3Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 300 &lt; p_{T} &lt; 400;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin4Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin4Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 400 &lt; p_{T} &lt; 500;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin4Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin4Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 400 &lt; p_{T} &lt; 500;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin5Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin5Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 500 &lt; p_{T} &lt; 600;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin5Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin5Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 500 &lt; p_{T} &lt; 600;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin6Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin6Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 600 &lt; p_{T} &lt; 700;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin6Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin6Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 600 &lt; p_{T} &lt; 700;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin7Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin7Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 700 &lt; p_{T} &lt; 800;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin7Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin7Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 700 &lt; p_{T} &lt; 800;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin8Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin8Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} 800 &lt; p_{T} &lt; 900;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWPtBin8Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWPtBin8Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} 800 &lt; p_{T} &lt; 900;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    <i><font color="#b22222">//for jet multiplicity bins
</font></i>    MC_CosThetaStar1RightPzWJetBin1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} num jets = 0 ;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} num jets = 0;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} num jets = 1;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} num jets = 1;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin3Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin3Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} num jets = 2;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin3Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin3Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} num jets = 2;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin4Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin4Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} num jets = 3;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin4Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin4Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} num jets = 3;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin5Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin5Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} num jets = 4;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin5Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin5Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} num jets = 4;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin6Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin6Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} num jets = 5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzWJetBin6Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzWJetBin6Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} num jets = 5;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);

    MC_CosThetaStar1WrongPzPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from correctly p_{z} boosted W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from correctly p_{z} boosted W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMHT2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMHT2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{+} MHT2;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMHT2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMHT2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{-} MHT2;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMHT2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMHT2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from correctly p_{z} boosted W^{+} MHT2;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMHT2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMHT2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from correctly p_{z} boosted W^{-} MHT2;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMuonMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMuonMinus"</b></font><b></b>,<font color="#bc8f8f"><b>"cos #theta^{*} from wrongly p_{z} boosted W^{-} + #mu cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMuonPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMuonPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{+} + #mu cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMuonMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMuonMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from rightly p_{z} boosted W^{-} + #mu cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMuonPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMuonPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from rightly p_{z} boosted W^{+} + #mu cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMuonMHT2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMuonMHT2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{+} + (#mu,MHT) cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMuonMHT2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMuonMHT2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{-} + (#mu,MHT) cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMuonMHT2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMuonMHT2Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from rightly p_{z} boosted W^{+} + (#mu,MHT) cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMuonMHT2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMuonMHT2Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from rightly p_{z} boosted W^{-} + (#mu,MHT) cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMuonMHT2RecoPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMuonMHT2RecoPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{+} + (#mu,MHT) Reco cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1WrongPzMuonMHT2RecoMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1WrongPzMuonMHT2RecoMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from wrongly p_{z} boosted W^{-} + (#mu,MHT) Reco cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMuonMHT2RecoPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMuonMHT2RecoPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from rightly p_{z} boosted W^{+} + (#mu,MHT) Reco cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);
    MC_CosThetaStar1RightPzMuonMHT2RecoMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1RightPzMuonMHT2RecoMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from rightly p_{z} boosted W^{-} + (#mu,MHT) Reco cuts;Events / 100 pb^{-1}"</b></font><b></b>,300,-1.5,1.5);

    MC_DiffPzWMuPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_DiffPzWMuPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";;#Delta(W^{+} p_{z}, #mu p_{z})Events / 100 pb^{-1}"</b></font><b></b>,2000,-1000.5,999.5);
    MC_DiffPzWMuMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_DiffPzWMuMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta(W^{-} p_{z}, #mu p_{z});Events / 100 pb^{-1}"</b></font><b></b>,2000,-1000.5,999.5);
    TH1::SetDefaultSumw2(kFALSE);

    <i><font color="#b22222">//reason we reset the setdefaultsumw2 flag is because of Warning in &lt;TH2::GetBinContent&gt;: this method must be overridden!
</font></i>    <i><font color="#b22222">//see here for more info: http://root.cern.ch/root/roottalk/roottalk08/0278.html
</font></i>    MC_MuonEtaCosThetaStar1Plus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_MuonEtaCosThetaStar1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+};#mu^{+} #eta"</b></font><b></b>,300,-1.5,1.5,1000,-5.5,4.5);
    MC_MuonEtaCosThetaStar1Minus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_MuonEtaCosThetaStar1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-};#mu^{-} #eta"</b></font><b></b>,300,-1.5,1.5,1000,-5.5,4.5);
    MC_MuonPtCosThetaStar1Plus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_MuonPtCosThetaStar1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+};#mu^{+} P_{t}"</b></font><b></b>,300,-1.5,1.5,1000,-0.5,999.5);
    MC_MuonPtCosThetaStar1Minus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_MuonPtCosThetaStar1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-};#mu^{-} P_{t}"</b></font><b></b>,300,-1.5,1.5,1000,-0.5,999.5);
    MC_WEtaCosThetaStar1Plus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WEtaCosThetaStar1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+};W^{+} #eta"</b></font><b></b>,300,-1.5,1.5,1000,-5.5,4.5);
    MC_WEtaCosThetaStar1Minus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WEtaCosThetaStar1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-};W^{-} #eta"</b></font><b></b>,300,-1.5,1.5,1000,-5.5,4.5);
    MC_WPtCosThetaStar1Plus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WPtCosThetaStar1Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{+};W^{+} P_{t}"</b></font><b></b>,300,-1.5,1.5,1000,-0.5,999.5);
    MC_WPtCosThetaStar1Minus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WPtCosThetaStar1Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";cos #theta^{*} from W^{-};W^{-} P_{t}"</b></font><b></b>,300,-1.5,1.5,1000,-0.5,999.5);
    MC_WPtPzPlus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WPtPzPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";W^{+} P_{z} / P_{T}; W^+ P_{T}"</b></font><b></b>,100,-0.5,99.5,1000,-0.5,999.5);
    MC_WPtPzMinus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WPtPzMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";W^{-} P_{z} / P_{T}; W^- P_{T}"</b></font><b></b>,100,-0.5,99.5,1000,-0.5,999.5);
    MC_WMuPtPzPlus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WMuPtPzPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";W^{+} / #mu^{+} P_{z};W^{+} / #mu^{+} P_{T}"</b></font><b></b>,2000,-10.005,9.995,1000,-0.005,9.995);
    MC_WMuPtPzMinus = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WMuPtPzMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";W^{-} / #mu^{-} P_{z};W^{-} / #mu^{+} P_{T}"</b></font><b></b>,2000,-10.005,9.995,1000,-0.005,9.995);
    MC_WPtY = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WPtY"</b></font><b></b>,<font color="#bc8f8f"><b>";W P_{T}; W |Y|"</b></font><b></b>,1000,-0.5,999.5,  50,-0.05,4.95);

    <i><font color="#b22222">//MC_InitialBoostDir = new TH1D("MC_InitialBoostDir",";InitialBoostDir;Events",4000,-1999.5,2000.5);
</font></i>    <i><font color="#b22222">//MC_FinalBoostDir = new TH1D("MC_FinalBoostDir",";FinalBoostDir;Events",4000,-1999.5,2000.5);
</font></i>  }

  <font color="#228b22"><b>bool</b></font><b></b> MCWPlots::Process(Event::Data &amp; ev) {
    GenMatrixBin myGenMatrixBin(&amp;ev);
    <i><font color="#b22222">//initialise some TLorentzVectors
</font></i>    TLorentzVector jRestMu, jRestQuark, jRestQuark2, jGenW, jGenLepton;
    Event::GenObject <font color="#228b22"><b>const</b></font><b></b> * genLepton;
    Event::GenObject <font color="#228b22"><b>const</b></font><b></b> * genLeptonNu;
    <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> counter = 0; <i><font color="#b22222">//just a temporary variable so we can tell how many particles share the same mother as the W
</font></i>    <i><font color="#b22222">//in general, since the W mass is large, use rapidity and not pseudo-rapidity in the plots (they are equivalent in the massless limit)
</font></i>
    <i><font color="#b22222">//the loop below goes through the particles in the GenMatrixBin identified as jets
</font></i>    <i><font color="#b22222">//these are the outgoing quarks and gluons - first we check that any of the outgoing quarks
</font></i>    <i><font color="#b22222">//shares the same mother as the W, then that it isn't a gluon. Finally we check that the
</font></i>    <i><font color="#b22222">//mother of the W has only 2 daughters
</font></i>    TLorentzVector jJetSum, jJetSum2; <i><font color="#b22222">//initialises as empty for each event
</font></i>    TLorentzVector jtempJetSum; <i><font color="#b22222">//for conversion from LorentzV to TLorentzVector
</font></i><i><font color="#b22222">/*
    //the next two lines are commented and replaced by the ones two lines below them due to the change in the dataformat
    //jGenW = *(myGenMatrixBin.the_GenW.at(0)); //the generator W
    //jGenMu = *(myGenMatrixBin.the_GenMuon.at(0)); //the muon from the W
    jGenW = TLVConvert(myGenMatrixBin.the_GenW.at(0));
    //we can make the below statements with confidence if we use the MCWLeptonExists cut which checks explicitly that the W decays to (one) lepton
    //and of course if we want to reproduce the muon plots, select to use MCWMuonExists (and similarly for other leptons...)
    if(myGenMatrixBin.the_GenEli.size()) {
      jGenLepton = TLVConvert(myGenMatrixBin.the_GenEli.at(0));
      genLepton = myGenMatrixBin.the_GenEli.at(0);
      genLeptonNu = myGenMatrixBin.the_GenEliNu.at(0);
    }
    if(myGenMatrixBin.the_GenMuon.size()) {
      jGenLepton = TLVConvert(myGenMatrixBin.the_GenMuon.at(0));
      genLepton = myGenMatrixBin.the_GenMuon.at(0);
      genLeptonNu = myGenMatrixBin.the_GenMuonNu.at(0);
    }
    if(myGenMatrixBin.the_GenTau.size()) {
      jGenLepton = TLVConvert(myGenMatrixBin.the_GenTau.at(0));
      genLepton = myGenMatrixBin.the_GenTau.at(0);
      genLeptonNu = myGenMatrixBin.the_GenTauNu.at(0);
    }
*/</font></i>

    <font color="#228b22"><b>bool</b></font><b></b> forW = true;
    <font color="#228b22"><b>bool</b></font><b></b> forZ = false;
    vector &lt;Event::GenObject <font color="#228b22"><b>const</b></font><b></b> *&gt; theVBosons;


    <b><font color="#a020f0">if</font></b>(forW) { 
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.size()==0) <b><font color="#a020f0">return</font></b> false;
      theVBosons = myGenMatrixBin.the_GenW;

      jGenW = TLVConvert(myGenMatrixBin.the_GenW.at(0));
      <i><font color="#b22222">//we can make the below statements with confidence if we use the MCWLeptonExists cut which checks explicitly that the W decays to (one) lepton
</font></i>      <i><font color="#b22222">//and of course if we want to reproduce the muon plots, select to use MCWMuonExists (and similarly for other leptons...)
</font></i>      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenEli.size()) {
	jGenLepton = TLVConvert(myGenMatrixBin.the_GenEli.at(0));
	genLepton = myGenMatrixBin.the_GenEli.at(0);
	genLeptonNu = myGenMatrixBin.the_GenEliNu.at(0);
      }
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size()) {
	jGenLepton = TLVConvert(myGenMatrixBin.the_GenMuon.at(0));
	genLepton = myGenMatrixBin.the_GenMuon.at(0);
	genLeptonNu = myGenMatrixBin.the_GenMuonNu.at(0);
      }
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenTau.size()) {
	jGenLepton = TLVConvert(myGenMatrixBin.the_GenTau.at(0));
	genLepton = myGenMatrixBin.the_GenTau.at(0);
	genLeptonNu = myGenMatrixBin.the_GenTauNu.at(0);
      }
    }



   <b><font color="#a020f0">if</font></b>(forZ)
     {
       <font color="#228b22"><b>bool</b></font><b></b> madeIt = false;

       <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenZ.size()==0) <b><font color="#a020f0">return</font></b> false;
       jGenW = TLVConvert(myGenMatrixBin.the_GenZ.at(0));
       theVBosons = myGenMatrixBin.the_GenZ;
       
       
       <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenEli.size()==2) {
	 madeIt=true;
	 <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenEli.at(0)-&gt;GetID()&lt;0)
	   {
	     jGenLepton = TLVConvert(myGenMatrixBin.the_GenEli.at(1));
	     genLepton = myGenMatrixBin.the_GenEli.at(1);
	     genLeptonNu = myGenMatrixBin.the_GenEliNu.at(0);
	   }
	 <b><font color="#a020f0">else</font></b>
	   {
	     jGenLepton = TLVConvert(myGenMatrixBin.the_GenEli.at(0));
	     genLepton = myGenMatrixBin.the_GenEli.at(0);
	     genLeptonNu = myGenMatrixBin.the_GenEliNu.at(1);
	   }
       }
       
       <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size()==2) {
	 madeIt=true;
	 <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.at(0)-&gt;GetID()&lt;0)
	   {
	     jGenLepton = TLVConvert(myGenMatrixBin.the_GenMuon.at(1));
	     genLepton = myGenMatrixBin.the_GenMuon.at(1);
	     genLeptonNu = myGenMatrixBin.the_GenMuonNu.at(0);
	   }
	 <b><font color="#a020f0">else</font></b>
	   {
	     jGenLepton = TLVConvert(myGenMatrixBin.the_GenMuon.at(0));
	     genLepton = myGenMatrixBin.the_GenMuon.at(0);
	     genLeptonNu = myGenMatrixBin.the_GenMuonNu.at(1);
	   }
       }
       
       <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenTau.size()==2) {
	 madeIt=true;
	 <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenTau.at(0)-&gt;GetID()&lt;0)
	   {
	     jGenLepton = TLVConvert(myGenMatrixBin.the_GenTau.at(1));
	     genLepton = myGenMatrixBin.the_GenTau.at(1);
	     genLeptonNu = myGenMatrixBin.the_GenTauNu.at(0);
	   }
	 <b><font color="#a020f0">else</font></b>
	   {
	     jGenLepton = TLVConvert(myGenMatrixBin.the_GenTau.at(0));
	     genLepton = myGenMatrixBin.the_GenTau.at(0);
	     genLeptonNu = myGenMatrixBin.the_GenTauNu.at(1);
	   }
       }
       <b><font color="#a020f0">if</font></b>(!madeIt)
	 {
	   cout &lt;&lt; <font color="#bc8f8f"><b>"MCWPlots::One legged Z???"</b></font><b></b>&lt;&lt;endl;
	   <b><font color="#a020f0">return</font></b> false;
	 }   
     }
   





    <b><font color="#a020f0">for</font></b>(<font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> i=0; i&lt;myGenMatrixBin.the_GenJets.size(); i++) {
      MC_JetPtAll-&gt;Fill(myGenMatrixBin.the_GenJets.at(i)-&gt;Pt(), ev.GetEventWeight()); <i><font color="#b22222">//get the genJet Pt distribution for all jets
</font></i>      MC_JetEtaAll-&gt;Fill(myGenMatrixBin.the_GenJets.at(i)-&gt;Eta(), ev.GetEventWeight()); <i><font color="#b22222">//get the genJet Eta distribution for all jets
</font></i>      <i><font color="#b22222">//jJetSum -= (*(myGenMatrixBin.the_GenJets.at(i))); //vectorially sum all final state quarks and gluons. take negative vector sum (=MHT =GenW). This line is now replaced by the next two lines, due to the change in the dataformat
</font></i>      jtempJetSum = TLVConvert(myGenMatrixBin.the_GenJets.at(i));
      jJetSum -= jtempJetSum;
      <i><font color="#b22222">//now do it like we do in reco, with a pt and eta cut on the individual jets going into the sum - see NOTE below
</font></i>      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.at(i)-&gt;Pt() &gt; 30.0 &amp;&amp; fabs(myGenMatrixBin.the_GenJets.at(i)-&gt;Eta() &lt; 3.0) ) jJetSum2 -= jtempJetSum; <i><font color="#b22222">//jJetSum2 -= (*(myGenMatrixBin.the_GenJets.at(i)));
</font></i>      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.at(i)-&gt;GetMother() == theVBosons.at(0)-&gt;GetMother() &amp;&amp; myGenMatrixBin.the_GenJets.at(i)-&gt;GetIndex() != 21) {
	<i><font color="#b22222">//jRestQuark = (*(myGenMatrixBin.the_GenJets.at(i)));
</font></i>        jRestQuark = jtempJetSum;
        counter++;
      }
    }

    MC_JetMultiplicityAll-&gt;Fill(myGenMatrixBin.the_GenJets.size(), ev.GetEventWeight());



    <i><font color="#b22222">//NOTE - The typical multiplicity for this selection of counter=1 is 1 jet. If the jet fails to pass the acceptance and pt cuts, then there will be, by definition no MHT
</font></i>    <i><font color="#b22222">//The result of this is a boost vector (0,0,-pz/m) which acts to take the muon away from the flight direction of the W, towards the cos theta = -1 bin
</font></i>    <i><font color="#b22222">//i.e. further away than it would normally have been if it had an x and y boost, since the angle we measure is a 3D one...
</font></i>    <i><font color="#b22222">//NOTE - To fill genJets in the GenMatrixBin there is already a cut on the jet energy &gt; 30 GeV...
</font></i>    <i><font color="#b22222">//NOTE - At the RECO level, we make a MHT Cut &gt; 100. so not sure the above is relevant...
</font></i>
    <i><font color="#b22222">//only if the W shares a mother with ONE outgoing quark do we do the following
</font></i>    <i><font color="#b22222">//There are 3 possibilities for working out cos(theta*)
</font></i>    <i><font color="#b22222">//1.Boost the muon into the W rest frame and calculate the angle between the muon and original W flight direction - this is the only thing we can do in real data.
</font></i>    <i><font color="#b22222">//2.Boost the outgoing quark into the W rest frame and calculate the angle between the muon and quark
</font></i>    <i><font color="#b22222">//3.Boost the W into the W+outgoing quark system rest frame and calculate the angle between the muon in the W rest frame and W direction after first boost
</font></i>    <i><font color="#b22222">//(The W+outgoing quark = a virtual quark in the production diagram)
</font></i>    <i><font color="#b22222">//the check on counter ==1 is there so we can do boosts 2 and 3 - boost 1 is done outside the if statement below.
</font></i>    <b><font color="#a020f0">if</font></b>(counter == 1) {
      jRestQuark2 = jRestQuark; <i><font color="#b22222">//duplicate the outgoing quark since we will boost it in two different ways
</font></i>      jRestMu = jGenLepton;
      jSol1Mu = jGenLepton; <i><font color="#b22222">//to boost the muon according to one of the two pz solutions
</font></i>      jSol2Mu = jGenLepton; <i><font color="#b22222">//and the other
</font></i>      jWrongMu = jGenLepton; <i><font color="#b22222">//and to see the effects of having 100% wrong choice on pz
</font></i>      jRightMu = jGenLepton; <i><font color="#b22222">//and also if you pick 100% right choice, but the effect of choosing mw*=mw
</font></i>      jBoost = jGenW.BoostVector();
      jBoost2 = (jRestQuark + jGenW).BoostVector();
      jRestMu.Boost(-jBoost);
      jRestQuark.Boost(-jBoost);
      jRestQuark2.Boost(-jBoost2);
      <i><font color="#b22222">//CosThetaStar1 = cos(ROOT::Math::VectorUtil::Angle(jRestMu,jGenW));
</font></i>      CosThetaStar2 = cos(ROOT::Math::VectorUtil::Angle(jRestMu,jRestQuark));
      CosThetaStar3 = cos(ROOT::Math::VectorUtil::Angle(jRestMu,jRestQuark2));
      delta_w_mu = jGenW.Pz() - jGenLepton.Pz();
      delta_w_mu_mu = fabs(delta_w_mu - jGenLepton.Pz());
      <i><font color="#b22222">//W+ has particle ID = +24
</font></i>      <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	<i><font color="#b22222">//MC_CosThetaStar1Plus-&gt;Fill(CosThetaStar1, ev.GetEventWeight());
</font></i>	MC_CosThetaStar2Plus-&gt;Fill(CosThetaStar2, ev.GetEventWeight());
	MC_CosThetaStar3Plus-&gt;Fill(CosThetaStar3, ev.GetEventWeight());
	MC_DiffPzWMuPlus-&gt;Fill(delta_w_mu, ev.GetEventWeight());
      } <b><font color="#a020f0">else</font></b> {
	<i><font color="#b22222">//MC_CosThetaStar1Minus-&gt;Fill(CosThetaStar1, ev.GetEventWeight());
</font></i>	MC_CosThetaStar2Minus-&gt;Fill(CosThetaStar2, ev.GetEventWeight());
	MC_CosThetaStar3Minus-&gt;Fill(CosThetaStar3, ev.GetEventWeight());
	MC_DiffPzWMuMinus-&gt;Fill(delta_w_mu, ev.GetEventWeight());
      }
    }

    <i><font color="#b22222">//the FindBoost method was developed after the above code was written (and since the above worked, don't touch hehe)
</font></i>    jMCSolW = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
    <b><font color="#a020f0">if</font></b>(jMCSolW.realSolutions) {
      <i><font color="#b22222">//to convert the index, cast the answer (0.0,2.0) to int 
</font></i>      <font color="#228b22"><b>int</b></font><b></b> index = <font color="#228b22"><b>int</b></font><b></b>( (jMCSolW.rightSol + 1.0) / 0.01 );
      <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	MC_CosThetaStar1Plus-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight());
	MC_MuonEtaCosThetaStar1Plus-&gt;Fill(jMCSolW.rightSol, jGenLepton.Eta(), ev.GetEventWeight());
	MC_WEtaCosThetaStar1Plus-&gt;Fill(jMCSolW.rightSol, jGenW.Eta(), ev.GetEventWeight());
	MC_MuonPtCosThetaStar1Plus-&gt;Fill(jMCSolW.rightSol, jGenLepton.Pt(), ev.GetEventWeight());
	MC_WPtCosThetaStar1Plus-&gt;Fill(jMCSolW.rightSol, jGenW.Pt(), ev.GetEventWeight());

	MC_CosThetaStar1Plus_LH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,0));<i><font color="#b22222">//LHP().at(index));//all_lh_plus.at(index));
</font></i>	<i><font color="#b22222">//std::cout &lt;&lt; "CorrFactor+ = " &lt;&lt; CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,0) &lt;&lt; std::endl;
</font></i>	MC_CosThetaStar1Plus_RH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,1));
	MC_CosThetaStar1Plus_LO-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,2));
      }<b><font color="#a020f0">else</font></b>{
	MC_CosThetaStar1Minus-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight());
	MC_MuonEtaCosThetaStar1Minus-&gt;Fill(jMCSolW.rightSol, jGenLepton.Eta(), ev.GetEventWeight());
	MC_WEtaCosThetaStar1Minus-&gt;Fill(jMCSolW.rightSol, jGenW.Eta(), ev.GetEventWeight());
	MC_MuonPtCosThetaStar1Minus-&gt;Fill(jMCSolW.rightSol, jGenLepton.Pt(), ev.GetEventWeight());
	MC_WPtCosThetaStar1Minus-&gt;Fill(jMCSolW.rightSol, jGenW.Pt(), ev.GetEventWeight());

	MC_CosThetaStar1Minus_LH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,0));<i><font color="#b22222">//LHM().at(index));//* all_lh_minus.at(index));
</font></i>	<i><font color="#b22222">//std::cout &lt;&lt; "CorrFactor- = " &lt;&lt; CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,0) &lt;&lt; std::endl;
</font></i>	MC_CosThetaStar1Minus_RH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,1));
	MC_CosThetaStar1Minus_LO-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,2));
      }
    }

    <i><font color="#b22222">//there might be a duplication with MC_JetPt and MC_JetPtAll above etc
</font></i>    MC_MuonMultiplicity-&gt;Fill(myGenMatrixBin.the_GenMuon.size(), ev.GetEventWeight());
    MC_MuonNuMultiplicity-&gt;Fill(myGenMatrixBin.the_GenMuonNu.size(), ev.GetEventWeight());
    MC_JetMultiplicity-&gt;Fill(myGenMatrixBin.the_GenJets.size(), ev.GetEventWeight());
    <b><font color="#a020f0">for</font></b>(<font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> i=0; i&lt;myGenMatrixBin.the_GenJets.size(); i++) {
      MC_JetPt-&gt;Fill(myGenMatrixBin.the_GenJets.at(i)-&gt;Pt(),ev.GetEventWeight());
      MC_JetEta-&gt;Fill(myGenMatrixBin.the_GenJets.at(i)-&gt;Eta(),ev.GetEventWeight());
    }

    <i><font color="#b22222">//plot distribution of the muons
</font></i>    MC_MuonPt-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
    MC_MuonEta-&gt;Fill(genLepton-&gt;Eta(), ev.GetEventWeight());
    MC_MuonEtaAbs-&gt;Fill(fabs(genLepton-&gt;Eta()), ev.GetEventWeight());
    MC_MuonNuPt-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
    MC_MuonNuEta-&gt;Fill(genLeptonNu-&gt;Eta(), ev.GetEventWeight());
    MC_MuonNuEtaAbs-&gt;Fill(fabs(genLeptonNu-&gt;Eta()), ev.GetEventWeight());
    <i><font color="#b22222">//add a couple of plots for the separate charges Pt and Eta of the muons and neutrinos
</font></i>    <i><font color="#b22222">//and the IC variable (projection of lepton pt to mht normalised to mht). These plots are in the format for the macro
</font></i>    <font color="#228b22"><b>double</b></font><b></b> ICVariable = ((genLepton-&gt;Px() * jJetSum.Px()) + (genLepton-&gt;Py() * jJetSum.Py())) / (jJetSum.Pt() * jJetSum.Pt());
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
      MC_MuonPtPlus-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
      MC_MuonNuPtPlus-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
      MC_MuonEtaPlus-&gt;Fill(genLepton-&gt;Eta(), ev.GetEventWeight());
      MC_MuonEtaAbsPlus-&gt;Fill(fabs(genLepton-&gt;Eta()), ev.GetEventWeight());
      MC_MuonNuEtaPlus-&gt;Fill(genLeptonNu-&gt;Eta(), ev.GetEventWeight());
      MC_MuonNuEtaAbsPlus-&gt;Fill(fabs(genLeptonNu-&gt;Eta()), ev.GetEventWeight());
      MC_ICVarPlus-&gt;Fill(ICVariable, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(jMCSolW.realSolutions) {
	<font color="#228b22"><b>int</b></font><b></b> index = <font color="#228b22"><b>int</b></font><b></b>( (jMCSolW.rightSol + 1.0) / 0.01 );
	MC_ICVarPlus_LH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,0));
	MC_ICVarPlus_RH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,1));
	MC_ICVarPlus_LO-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,2));
      }
    }<b><font color="#a020f0">else</font></b>{
      MC_MuonPtMinus-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
      MC_MuonNuPtMinus-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
      MC_MuonEtaMinus-&gt;Fill(genLepton-&gt;Eta(), ev.GetEventWeight());
      MC_MuonEtaAbsMinus-&gt;Fill(fabs(genLepton-&gt;Eta()), ev.GetEventWeight());
      MC_MuonNuEtaMinus-&gt;Fill(genLeptonNu-&gt;Eta(), ev.GetEventWeight());
      MC_MuonNuEtaAbsMinus-&gt;Fill(fabs(genLeptonNu-&gt;Eta()), ev.GetEventWeight());
      MC_ICVarMinus-&gt;Fill(ICVariable, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(jMCSolW.realSolutions) {
	<font color="#228b22"><b>int</b></font><b></b> index = <font color="#228b22"><b>int</b></font><b></b>( (jMCSolW.rightSol + 1.0) / 0.01 );
	MC_ICVarMinus_LH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,0));
	MC_ICVarMinus_RH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,1));
	MC_ICVarMinus_LO-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,2));
      }
    }

    <i><font color="#b22222">//now we'd like to plot both the cos(theta*) and LP variable with muon acceptance (pt&gt;20, |eta|&lt;2.1) and make templates too to see how good the fit is...
</font></i>    <b><font color="#a020f0">if</font></b>(jMCSolW.realSolutions) {
      <b><font color="#a020f0">if</font></b>(jGenLepton.Pt() &gt; 20.0 &amp;&amp; fabs(jGenLepton.Eta()) &lt; 2.1) {
	<font color="#228b22"><b>int</b></font><b></b> index = <font color="#228b22"><b>int</b></font><b></b>( (jMCSolW.rightSol + 1.0) / 0.01 );
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1PlusMuonAcc-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight());
	  MC_CosThetaStar1PlusMuonAcc_LH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,0));	  
	  MC_CosThetaStar1PlusMuonAcc_RH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,1));
	  MC_CosThetaStar1PlusMuonAcc_LO-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,2));

	  MC_ICVarPlusMuonAcc-&gt;Fill(ICVariable, ev.GetEventWeight());
	  MC_ICVarPlusMuonAcc_LH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,0));
	  MC_ICVarPlusMuonAcc_RH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,1));
	  MC_ICVarPlusMuonAcc_LO-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,true,2));

	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1MinusMuonAcc-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight());
	  MC_CosThetaStar1MinusMuonAcc_LH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,0));	  
	  MC_CosThetaStar1MinusMuonAcc_RH-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,1));
	  MC_CosThetaStar1MinusMuonAcc_LO-&gt;Fill(jMCSolW.rightSol, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,2));

	  MC_ICVarMinusMuonAcc-&gt;Fill(ICVariable, ev.GetEventWeight());
	  MC_ICVarMinusMuonAcc_LH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,0));
	  MC_ICVarMinusMuonAcc_RH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,1));
	  MC_ICVarMinusMuonAcc_LO-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(theVBosons.at(0)-&gt;Pt(), theVBosons.at(0)-&gt;Rapidity(),index,false,2));
	}
      }
    }

    MC_JetMHT-&gt;Fill(jJetSum.Pt(), ev.GetEventWeight());
    MC_JetMHT2-&gt;Fill(jJetSum2.Pt(), ev.GetEventWeight());

    MC_VirtualWMass-&gt;Fill(jGenW.M(), ev.GetEventWeight());
    MC_MHTGenJetsWPtDiff-&gt;Fill((jJetSum.Pt() - jGenW.Pt())/jGenW.Pt(), ev.GetEventWeight());
    MC_MHT2GenJetsWPtDiff-&gt;Fill((jJetSum2.Pt() - jGenW.Pt())/jGenW.Pt(), ev.GetEventWeight());

    <i><font color="#b22222">//to see the effects of the W left handedness, plot the muon and neutrino spectra for two different muon pt cuts
</font></i>    <i><font color="#b22222">//point is that mu- is opposite to W-, so a cut on low pt mu- effects high pt neutrino, hence MET, spectra...
</font></i>    <i><font color="#b22222">//to pass the MCWMuon Cut, there must be a muon neutrino in this event...
</font></i>    <b><font color="#a020f0">if</font></b>(fabs(genLepton-&gt;Eta()) &lt; 2.1) {
      <b><font color="#a020f0">if</font></b>(genLepton-&gt;Pt() &gt; 10.0) {
	  MC_MuonPtCut1-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
	  MC_MuonEtaCut1-&gt;Fill(fabs(genLepton-&gt;Eta()), ev.GetEventWeight());
	  MC_MuonNuPtCut1-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
	  MC_MuonNuEtaCut1-&gt;Fill(fabs(genLeptonNu-&gt;Eta()), ev.GetEventWeight());
	  <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	    MC_MuonNuPtCut1Plus-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
	    MC_MuonPtCut1Plus-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
	  }<b><font color="#a020f0">else</font></b>{
	    MC_MuonNuPtCut1Minus-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
	    MC_MuonPtCut1Minus-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());	  
	  }
      }
      <b><font color="#a020f0">if</font></b>(genLepton-&gt;Pt() &gt; 20.0) {
	  MC_MuonPtCut2-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
	  MC_MuonEtaCut2-&gt;Fill(fabs(genLepton-&gt;Eta()), ev.GetEventWeight());
	  MC_MuonNuPtCut2-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
	  MC_MuonNuEtaCut2-&gt;Fill(fabs(genLeptonNu-&gt;Eta()), ev.GetEventWeight());
	  <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	    MC_MuonNuPtCut2Plus-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
	    MC_MuonPtCut2Plus-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());
	  }<b><font color="#a020f0">else</font></b>{
	    MC_MuonNuPtCut2Minus-&gt;Fill(genLeptonNu-&gt;Pt(), ev.GetEventWeight());
	    MC_MuonPtCut2Minus-&gt;Fill(genLepton-&gt;Pt(), ev.GetEventWeight());	  
	  }
      }
    }

    <i><font color="#b22222">//The above plots are a cheaty way to see how the different polarisation components change with respect to W eta and pt
</font></i>    <i><font color="#b22222">//They won't reveal anything useful if the underlying distribution is symmetric as it will change both by the same amount
</font></i>    <i><font color="#b22222">//The plots that follow show CosThetaStar1 Plus and Minus in bins of W eta, from 0.0 - 5.0 and above!
</font></i>    <i><font color="#b22222">//Eta was replaced with Rapidity as the W mass is not negligible!
</font></i>    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 0.0 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 0.5 ) {
      jMCSolWEtaBin1 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin1.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin1Plus-&gt;Fill(jMCSolWEtaBin1.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin1Minus-&gt;Fill(jMCSolWEtaBin1.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 0.5 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 1.0 ) {
      jMCSolWEtaBin2 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin2.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin2Plus-&gt;Fill(jMCSolWEtaBin2.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin2Minus-&gt;Fill(jMCSolWEtaBin2.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 1.0 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 1.5 ) {
      jMCSolWEtaBin3 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin3.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin3Plus-&gt;Fill(jMCSolWEtaBin3.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin3Minus-&gt;Fill(jMCSolWEtaBin3.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 1.5 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 2.0 ) {
      jMCSolWEtaBin4 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin4.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin4Plus-&gt;Fill(jMCSolWEtaBin4.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin4Minus-&gt;Fill(jMCSolWEtaBin4.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 2.0 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 2.5 ) {
      jMCSolWEtaBin5 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin5.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin5Plus-&gt;Fill(jMCSolWEtaBin5.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin5Minus-&gt;Fill(jMCSolWEtaBin5.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 2.5 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 3.0 ) {
      jMCSolWEtaBin6 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin6.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin6Plus-&gt;Fill(jMCSolWEtaBin6.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin6Minus-&gt;Fill(jMCSolWEtaBin6.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 3.0 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 3.5 ) {
      jMCSolWEtaBin7 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin7.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin7Plus-&gt;Fill(jMCSolWEtaBin7.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin7Minus-&gt;Fill(jMCSolWEtaBin7.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 3.5 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 4.0 ) {
      jMCSolWEtaBin8 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin8.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin8Plus-&gt;Fill(jMCSolWEtaBin8.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin8Minus-&gt;Fill(jMCSolWEtaBin8.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 4.0 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 4.5 ) {
      jMCSolWEtaBin9 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin9.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin9Plus-&gt;Fill(jMCSolWEtaBin9.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin9Minus-&gt;Fill(jMCSolWEtaBin9.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 4.5 &amp;&amp; fabs(theVBosons.at(0)-&gt;Rapidity()) &lt;= 5.0 ) {
      jMCSolWEtaBin10 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin10.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin10Plus-&gt;Fill(jMCSolWEtaBin10.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin10Minus-&gt;Fill(jMCSolWEtaBin10.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>( fabs(theVBosons.at(0)-&gt;Rapidity()) &gt; 5.0 ) {
      jMCSolWEtaBin11 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWEtaBin11.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin11Plus-&gt;Fill(jMCSolWEtaBin11.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWEtaBin11Minus-&gt;Fill(jMCSolWEtaBin11.rightSol, ev.GetEventWeight());
	}
      }
    }

    <i><font color="#b22222">//now we do the same thing for bins of W_Pt
</font></i>    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 100 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 200) {
      jMCSolWPtBin1 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin1.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin1Plus-&gt;Fill(jMCSolWPtBin1.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin1Minus-&gt;Fill(jMCSolWPtBin1.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 200 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 300) {
      jMCSolWPtBin2 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin2.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin2Plus-&gt;Fill(jMCSolWPtBin2.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin2Minus-&gt;Fill(jMCSolWPtBin2.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 300 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 400) {
      jMCSolWPtBin3 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin3.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin3Plus-&gt;Fill(jMCSolWPtBin3.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin3Minus-&gt;Fill(jMCSolWPtBin3.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 400 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 500) {
      jMCSolWPtBin4 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin4.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin4Plus-&gt;Fill(jMCSolWPtBin4.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin4Minus-&gt;Fill(jMCSolWPtBin4.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 500 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 600) {
      jMCSolWPtBin5 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin5.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin5Plus-&gt;Fill(jMCSolWPtBin5.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin5Minus-&gt;Fill(jMCSolWPtBin5.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 600 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 700) {
      jMCSolWPtBin6 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin6.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin6Plus-&gt;Fill(jMCSolWPtBin6.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin6Minus-&gt;Fill(jMCSolWPtBin6.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 700 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 800) {
      jMCSolWPtBin7 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin7.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin7Plus-&gt;Fill(jMCSolWPtBin7.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin7Minus-&gt;Fill(jMCSolWPtBin7.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;Pt() &gt; 800 &amp;&amp; theVBosons.at(0)-&gt;Pt() &lt;= 900) {
      jMCSolWPtBin8 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWPtBin8.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWPtBin8Plus-&gt;Fill(jMCSolWPtBin8.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWPtBin8Minus-&gt;Fill(jMCSolWPtBin8.rightSol, ev.GetEventWeight());
	}
      }
    }

    <i><font color="#b22222">//and finally in bins of jet multiplicity
</font></i>    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.size() == 0) {
      jMCSolWJetBin1 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWJetBin1.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWJetBin1Plus-&gt;Fill(jMCSolWJetBin1.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWJetBin1Minus-&gt;Fill(jMCSolWJetBin1.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.size() == 1) {
      jMCSolWJetBin2 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWJetBin2.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWJetBin2Plus-&gt;Fill(jMCSolWJetBin2.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWJetBin2Minus-&gt;Fill(jMCSolWJetBin2.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.size() == 2) {
      jMCSolWJetBin3 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWJetBin3.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWJetBin3Plus-&gt;Fill(jMCSolWJetBin3.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWJetBin3Minus-&gt;Fill(jMCSolWJetBin3.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.size() == 3) {
      jMCSolWJetBin4 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWJetBin4.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWJetBin4Plus-&gt;Fill(jMCSolWJetBin4.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWJetBin4Minus-&gt;Fill(jMCSolWJetBin4.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.size() == 4) {
      jMCSolWJetBin5 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWJetBin5.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWJetBin5Plus-&gt;Fill(jMCSolWJetBin5.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWJetBin5Minus-&gt;Fill(jMCSolWJetBin5.rightSol, ev.GetEventWeight());
	}
      }
    }
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenJets.size() == 5) {
      jMCSolWJetBin6 = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      <b><font color="#a020f0">if</font></b>(jMCSolWJetBin6.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWJetBin6Plus-&gt;Fill(jMCSolWJetBin6.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1RightPzWJetBin6Minus-&gt;Fill(jMCSolWJetBin6.rightSol, ev.GetEventWeight());
	}
      }
    }


    <i><font color="#b22222">//now play with different variables affecting measurement of cos(theta*) variable at gen level
</font></i>    jMCSol = FindBoost(jGenLepton, jGenW.Px(), jGenW.Py(), jGenW.Pz());

    <b><font color="#a020f0">if</font></b>(jMCSol.realSolutions) {
      <i><font color="#b22222">//plot the VirtualW mass for real solutions to pz
</font></i>      MC_VirtualWMassRe-&gt;Fill(jGenW.M(), ev.GetEventWeight());
	
      <i><font color="#b22222">//remember that whilst the muon has a positive ID but negative charge, the W+ has ID +24
</font></i>      <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	MC_CosThetaStar1WrongPzPlus-&gt;Fill(jMCSol.wrongSol, ev.GetEventWeight());
	MC_CosThetaStar1RightPzPlus-&gt;Fill(jMCSol.rightSol, ev.GetEventWeight());
      }<b><font color="#a020f0">else</font></b>{
	MC_CosThetaStar1WrongPzMinus-&gt;Fill(jMCSol.wrongSol, ev.GetEventWeight());
	MC_CosThetaStar1RightPzMinus-&gt;Fill(jMCSol.rightSol, ev.GetEventWeight());
      }	
    }<b><font color="#a020f0">else</font></b>{
      MC_VirtualWMassIm-&gt;Fill(jGenW.M(), ev.GetEventWeight());
    }

    <b><font color="#a020f0">if</font></b>(jJetSum2.Pt() &gt; 100.0) {
      <i><font color="#b22222">//MHT2 relates to making jet et and eta cuts contributing to the MHT calculation
</font></i>      jMCSolMHT2 = FindBoost(jGenLepton, jJetSum2.Px(), jJetSum2.Py(), jGenW.Pz());

      <b><font color="#a020f0">if</font></b>(jMCSolMHT2.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1WrongPzMHT2Plus-&gt;Fill(jMCSolMHT2.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMHT2Plus-&gt;Fill(jMCSolMHT2.rightSol, ev.GetEventWeight());	  
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1WrongPzMHT2Minus-&gt;Fill(jMCSolMHT2.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMHT2Minus-&gt;Fill(jMCSolMHT2.rightSol, ev.GetEventWeight());
	}
      }
    }

    <i><font color="#b22222">//again, we emulate the RECO cuts, this time on the muon, to see the effects at gen level on the cos(theta*) dist
</font></i>    <b><font color="#a020f0">if</font></b>(jGenLepton.Pt() &gt; 15.0 &amp;&amp; fabs(jGenLepton.Eta()) &lt; 2.1) {
      jMCSolMuon = FindBoost(jGenLepton,jGenW.Px(),jGenW.Py(),jGenW.Pz());

      <b><font color="#a020f0">if</font></b>(jMCSolMuon.realSolutions) {
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1WrongPzMuonPlus-&gt;Fill(jMCSolMuon.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMuonPlus-&gt;Fill(jMCSolMuon.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1WrongPzMuonMinus-&gt;Fill(jMCSolMuon.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMuonMinus-&gt;Fill(jMCSolMuon.rightSol, ev.GetEventWeight());
	}
      }
    }

    <i><font color="#b22222">//now mix all the criteria together at generator level
</font></i>    <b><font color="#a020f0">if</font></b>(jGenLepton.Pt() &gt; 15.0 &amp;&amp; fabs(jGenLepton.Eta()) &lt; 2.1 &amp;&amp; jJetSum2.Pt() &gt; 100.0) {
      jMCSolMuonMHT2 = FindBoost(jGenLepton, jJetSum2.Px(), jJetSum2.Py(), jGenW.Pz());
     
      <b><font color="#a020f0">if</font></b>(jMCSolMuonMHT2.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1WrongPzMuonMHT2Plus-&gt;Fill(jMCSolMuonMHT2.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMuonMHT2Plus-&gt;Fill(jMCSolMuonMHT2.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1WrongPzMuonMHT2Minus-&gt;Fill(jMCSolMuonMHT2.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMuonMHT2Minus-&gt;Fill(jMCSolMuonMHT2.rightSol, ev.GetEventWeight());
	}
      }
    }

    <i><font color="#b22222">//now try doing the same with the RECO quantities (where we can cheat with the real Pz)
</font></i>    <i><font color="#b22222">//remember that when the commonmuons are filled, they have to pass the pt&gt;commonmuonetcut_gev and fabs(eta)&lt;commonmuoneta cuts...
</font></i>    <i><font color="#b22222">//we don't make the numcomleptons cut though...
</font></i>    <b><font color="#a020f0">if</font></b>(ev.LD_CommonMuons().accepted.size() == 1 &amp;&amp; ev.CommonMHT().Pt() &gt; 100.0) {
      <i><font color="#b22222">//jMCSolMuonMHT2Reco = FindBoost(*(ev.LD_CommonMuons().accepted.at(0)), ev.CommonMHT().Px(), ev.CommonMHT().Py(), jGenW.Pz());
</font></i>      jMCSolMuonMHT2Reco = FindBoost(TLVConvert(ev.LD_CommonMuons().accepted.at(0)), ev.CommonMHT().Px(), ev.CommonMHT().Py(), jGenW.Pz());

      <b><font color="#a020f0">if</font></b>(jMCSolMuonMHT2Reco.realSolutions){
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1WrongPzMuonMHT2RecoPlus-&gt;Fill(jMCSolMuonMHT2Reco.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMuonMHT2RecoPlus-&gt;Fill(jMCSolMuonMHT2Reco.rightSol, ev.GetEventWeight());
	}<b><font color="#a020f0">else</font></b>{
	  MC_CosThetaStar1WrongPzMuonMHT2RecoMinus-&gt;Fill(jMCSolMuonMHT2Reco.wrongSol, ev.GetEventWeight());
	  MC_CosThetaStar1RightPzMuonMHT2RecoMinus-&gt;Fill(jMCSolMuonMHT2Reco.rightSol, ev.GetEventWeight());
	}
      }
    }

    MC_WMultiplicity-&gt;Fill(theVBosons.size(), ev.GetEventWeight());
    MC_WPT-&gt;Fill(theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
    MC_WEta-&gt;Fill(theVBosons.at(0)-&gt;Eta(), ev.GetEventWeight());
    MC_WY-&gt;Fill(theVBosons.at(0)-&gt;Rapidity(), ev.GetEventWeight());
    MC_WPtY-&gt;Fill(theVBosons.at(0)-&gt;Pt(), fabs(theVBosons.at(0)-&gt;Rapidity()), ev.GetEventWeight()); 
    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
      MC_WPtPlus-&gt;Fill(theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
      <i><font color="#b22222">//cout &lt;&lt; "W after boost: " &lt;&lt; theVBosons.at(0)-&gt;Px() &lt;&lt; ", " &lt;&lt; theVBosons.at(0)-&gt;Py() &lt;&lt; ", " &lt;&lt; theVBosons.at(0)-&gt;Pz() &lt;&lt; endl;
</font></i>      <i><font color="#b22222">//cout &lt;&lt; "W theta in plottingop: " &lt;&lt; theVBosons.at(0)-&gt;Theta() &lt;&lt; endl &lt;&lt; endl;
</font></i>      MC_WEtaPlus-&gt;Fill(fabs(theVBosons.at(0)-&gt;Eta()), ev.GetEventWeight());
      MC_WYPlus-&gt;Fill(fabs(theVBosons.at(0)-&gt;Rapidity()), ev.GetEventWeight());
      MC_WPtPzPlus-&gt;Fill(fabs(theVBosons.at(0)-&gt;Pz() / theVBosons.at(0)-&gt;Pt()), theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
      MC_WMuPtPzPlus-&gt;Fill(genLepton-&gt;Pz() / theVBosons.at(0)-&gt;Pz(),genLepton-&gt;Pt() / theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
    }<b><font color="#a020f0">else</font></b>{
      MC_WPtMinus-&gt;Fill(theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
      MC_WEtaMinus-&gt;Fill(fabs(theVBosons.at(0)-&gt;Eta()), ev.GetEventWeight());
      MC_WYMinus-&gt;Fill(fabs(theVBosons.at(0)-&gt;Rapidity()), ev.GetEventWeight());
      MC_WPtPzMinus-&gt;Fill(fabs(theVBosons.at(0)-&gt;Pz() / theVBosons.at(0)-&gt;Pt()), theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
      MC_WMuPtPzMinus-&gt;Fill(genLepton-&gt;Pz() / theVBosons.at(0)-&gt;Pz(),genLepton-&gt;Pt() / theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
    }
    MC_MHTAllGenJetsWPtDiff-&gt;Fill((jJetSum.Pt() - theVBosons.at(0)-&gt;Pt())/theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());

    <i><font color="#b22222">//MC_FinalBoostDir-&gt;Fill(myGenMatrixBin.finalBoostDir, ev.GetEventWeight());
</font></i>    <i><font color="#b22222">//MC_InitialBoostDir-&gt;Fill(myGenMatrixBin.initialBoostDir, ev.GetEventWeight());
</font></i>
    <b><font color="#a020f0">return</font></b> true;
  }

  std::ostream&amp; MCWPlots::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; <font color="#bc8f8f"><b>"Generator W boson plots"</b></font><b></b>;
    <b><font color="#a020f0">return</font></b> ostrm;
  }

  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// MCWCOMPlots implementation 
</font></i>  <i><font color="#b22222">//====================================
</font></i><i><font color="#b22222">/*  
  MCWCOMPlots::MCWCOMPlots(const std::string &amp; folderName) :
    mFolderName(folderName) {}
   
  MCWCOMPlots::~MCWCOMPlots() {}

  void MCWCOMPlots::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  void MCWCOMPlots::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    //for W Eta bins
    MC_CosThetaStar1RightPzWEtaBin1Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin1Plus",";cos #theta^{*} from W^{+} -5.0 &lt; Y &lt; -4.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin1Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin1Minus",";cos #theta^{*} from W^{-} -5.0 &lt; Y &lt; -4.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin2Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin2Plus",";cos #theta^{*} from W^{+} -4.5 &lt; Y &lt; -4.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin2Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin2Minus",";cos #theta^{*} from W^{-} -4.5 &lt; Y &lt; -4.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin3Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin3Plus",";cos #theta^{*} from W^{+} -4.0 &lt; Y &lt; -3.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin3Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin3Minus",";cos #theta^{*} from W^{-} -4.0 &lt; Y &lt; -3.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin4Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin4Plus",";cos #theta^{*} from W^{+} -3.5 &lt; Y &lt; -3.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin4Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin4Minus",";cos #theta^{*} from W^{-} -3.5 &lt; Y &lt; -3.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin5Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin5Plus",";cos #theta^{*} from W^{+} -3.0 &lt; Y &lt; -2.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin5Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin5Minus",";cos #theta^{*} from W^{-} -3.0 &lt; Y &lt; -2.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin6Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin6Plus",";cos #theta^{*} from W^{+} -2.5 &lt; Y &lt; -2.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin6Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin6Minus",";cos #theta^{*} from W^{-} -2.5 &lt; Y &lt; -2.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin7Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin7Plus",";cos #theta^{*} from W^{+} -2.0 &lt; Y &lt; -1.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin7Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin7Minus",";cos #theta^{*} from W^{-} -2.0 &lt; Y &lt; -1.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin8Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin8Plus",";cos #theta^{*} from W^{+} -1.5 &lt; Y &lt; -1.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin8Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin8Minus",";cos #theta^{*} from W^{-} -1.5 &lt; Y &lt; -1.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin9Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin9Plus",";cos #theta^{*} from W^{+} -1.0 &lt; Y &lt; -0.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin9Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin9Minus",";cos #theta^{*} from W^{-} -1.0 &lt; Y &lt; -0.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin10Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin10Plus",";cos #theta^{*} from W^{+} -0.5 &lt; Y &lt; 0.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin10Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin10Minus",";cos #theta^{*} from W^{-} -0.5 &lt; Y &lt; 0.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin11Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin11Plus",";cos #theta^{*} from W^{+} 0.0 &lt; Y &lt; 0.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin11Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin11Minus",";cos #theta^{*} from W^{-} 0.0 &lt; Y &lt; 0.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin12Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin12Plus",";cos #theta^{*} from W^{+} 0.5 &lt; Y &lt; 1.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin12Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin12Minus",";cos #theta^{*} from W^{-} 0.5 &lt; Y &lt; 1.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin13Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin13Plus",";cos #theta^{*} from W^{+} 1.0 &lt; Y &lt; 1.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin13Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin13Minus",";cos #theta^{*} from W^{-} 1.0 &lt; Y &lt; 1.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin14Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin14Plus",";cos #theta^{*} from W^{+} 1.5 &lt; Y &lt; 2.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin14Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin14Minus",";cos #theta^{*} from W^{-} 1.5 &lt; Y &lt; 2.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin15Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin15Plus",";cos #theta^{*} from W^{+} 2.0 &lt; Y &lt; 2.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin15Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin15Minus",";cos #theta^{*} from W^{-} 2.0 &lt; Y &lt; 2.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin16Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin16Plus",";cos #theta^{*} from W^{+} 2.5 &lt; Y &lt; 3.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin16Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin16Minus",";cos #theta^{*} from W^{-} 2.5 &lt; Y &lt; 3.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin17Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin17Plus",";cos #theta^{*} from W^{+} 3.0 &lt; Y &lt; 3.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin17Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin17Minus",";cos #theta^{*} from W^{-} 3.0 &lt; Y &lt; 3.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin18Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin18Plus",";cos #theta^{*} from W^{+} 3.5 &lt; Y &lt; 4.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin18Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin18Minus",";cos #theta^{*} from W^{-} 3.5 &lt; Y &lt; 4.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin19Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin19Plus",";cos #theta^{*} from W^{+} 4.0 &lt; Y &lt; 4.5;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin19Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin19Minus",";cos #theta^{*} from W^{-} 4.0 &lt; Y &lt; 4.5;Events / 100 pb^{-1}",300,-1.5,1.5);

    MC_CosThetaStar1RightPzWEtaBin20Plus = new TH1D("MC_CosThetaStar1RightPzWEtaBin20Plus",";cos #theta^{*} from W^{+} 4.5 &lt; Y &lt; 5.0;Events / 100 pb^{-1}",300,-1.5,1.5);
    MC_CosThetaStar1RightPzWEtaBin20Minus = new TH1D("MC_CosThetaStar1RightPzWEtaBin20Minus",";cos #theta^{*} from W^{-} 4.5 &lt; Y &lt; 5.0;Events / 100 pb^{-1}",300,-1.5,1.5);

    TH1::SetDefaultSumw2(kFALSE);
  }

  bool MCWCOMPlots::Process(Event::Data &amp; ev) {
    GenMatrixBin myGenMatrixBin(&amp;ev);


    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -5.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -4.5 ) {
      jMCSolWEtaBin1 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin1.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin1Plus-&gt;Fill(jMCSolWEtaBin1.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin1Minus-&gt;Fill(jMCSolWEtaBin1.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -4.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -4.0 ) {
      jMCSolWEtaBin2 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin2.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin2Plus-&gt;Fill(jMCSolWEtaBin2.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin2Minus-&gt;Fill(jMCSolWEtaBin2.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -4.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -3.5 ) {
      jMCSolWEtaBin3 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin3.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin3Plus-&gt;Fill(jMCSolWEtaBin3.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin3Minus-&gt;Fill(jMCSolWEtaBin3.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -3.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -3.0 ) {
      jMCSolWEtaBin4 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin4.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin4Plus-&gt;Fill(jMCSolWEtaBin4.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin4Minus-&gt;Fill(jMCSolWEtaBin4.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -3.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -2.5 ) {
      jMCSolWEtaBin5 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin5.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin5Plus-&gt;Fill(jMCSolWEtaBin5.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin5Minus-&gt;Fill(jMCSolWEtaBin5.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -2.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -2.0 ) {
      jMCSolWEtaBin6 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin6.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin6Plus-&gt;Fill(jMCSolWEtaBin6.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin6Minus-&gt;Fill(jMCSolWEtaBin6.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -2.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -1.5 ) {
      jMCSolWEtaBin7 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin7.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin7Plus-&gt;Fill(jMCSolWEtaBin7.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin7Minus-&gt;Fill(jMCSolWEtaBin7.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -1.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -1.0 ) {
      jMCSolWEtaBin8 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin8.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin8Plus-&gt;Fill(jMCSolWEtaBin8.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin8Minus-&gt;Fill(jMCSolWEtaBin8.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -1.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= -0.5 ) {
      jMCSolWEtaBin9 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin9.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin9Plus-&gt;Fill(jMCSolWEtaBin9.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin9Minus-&gt;Fill(jMCSolWEtaBin9.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; -0.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 0.0 ) {
      jMCSolWEtaBin10 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin10.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin10Plus-&gt;Fill(jMCSolWEtaBin10.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin10Minus-&gt;Fill(jMCSolWEtaBin10.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 0.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 0.5 ) {
      jMCSolWEtaBin11 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin11.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin11Plus-&gt;Fill(jMCSolWEtaBin11.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin11Minus-&gt;Fill(jMCSolWEtaBin11.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 0.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 1.0 ) {
      jMCSolWEtaBin12 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin12.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin12Plus-&gt;Fill(jMCSolWEtaBin12.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin12Minus-&gt;Fill(jMCSolWEtaBin12.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 1.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 1.5 ) {
      jMCSolWEtaBin13 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin13.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin13Plus-&gt;Fill(jMCSolWEtaBin13.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin13Minus-&gt;Fill(jMCSolWEtaBin13.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 1.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 2.0 ) {
      jMCSolWEtaBin14 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin14.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin14Plus-&gt;Fill(jMCSolWEtaBin14.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin14Minus-&gt;Fill(jMCSolWEtaBin14.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 2.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 2.5 ) {
      jMCSolWEtaBin15 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin15.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin15Plus-&gt;Fill(jMCSolWEtaBin15.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin15Minus-&gt;Fill(jMCSolWEtaBin15.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 2.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 3.0 ) {
      jMCSolWEtaBin16 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin16.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin16Plus-&gt;Fill(jMCSolWEtaBin16.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin16Minus-&gt;Fill(jMCSolWEtaBin16.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 3.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 3.5 ) {
      jMCSolWEtaBin17 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin17.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin17Plus-&gt;Fill(jMCSolWEtaBin17.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin17Minus-&gt;Fill(jMCSolWEtaBin17.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 3.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 4.0 ) {
      jMCSolWEtaBin18 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin18.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin18Plus-&gt;Fill(jMCSolWEtaBin18.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin18Minus-&gt;Fill(jMCSolWEtaBin18.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 4.0 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 4.5 ) {
      jMCSolWEtaBin19 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin19.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin19Plus-&gt;Fill(jMCSolWEtaBin19.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin19Minus-&gt;Fill(jMCSolWEtaBin19.rightSol, ev.GetEventWeight());
	}
      }
    }
    if( myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &gt; 4.5 &amp;&amp; myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity() &lt;= 5.0 ) {
      jMCSolWEtaBin20 = FindBoost(jGenMu, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
      if(jMCSolWEtaBin20.realSolutions){
	if(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
	  MC_CosThetaStar1RightPzWEtaBin20Plus-&gt;Fill(jMCSolWEtaBin20.rightSol, ev.GetEventWeight());
	}else{
	  MC_CosThetaStar1RightPzWEtaBin20Minus-&gt;Fill(jMCSolWEtaBin20.rightSol, ev.GetEventWeight());
	}
      }
    }

    return true;
  }

  std::ostream&amp; MCWCOMPlots::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; "Generator W boson plots in the centre of mass frame";
    return ostrm;
  }
*/</font></i>

  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// MCPolPlots implementation 
</font></i>  <i><font color="#b22222">//====================================
</font></i>  
  MCPolPlots::MCPolPlots(<font color="#228b22"><b>const</b></font><b></b> std::string &amp; folderName) :
    mFolderName(folderName) {}
   
  MCPolPlots::~MCPolPlots() {}

  <font color="#228b22"><b>void</b></font><b></b> MCPolPlots::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  <font color="#228b22"><b>void</b></font><b></b> MCPolPlots::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    MC_MuonPt = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonPt"</b></font><b></b>, <font color="#bc8f8f"><b>";#mu P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_MuonEta =  <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonEta"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu #eta;Events / 100 pb^{-1}"</b></font><b></b>,100, -5.5, 4.5);
    MC_MuonMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonMultiplicity"</b></font><b></b>, <font color="#bc8f8f"><b>";MC MuonExtra Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_MHT = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MHT"</b></font><b></b>, <font color="#bc8f8f"><b>";MHT;Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    MC_ICVarPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^+;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_ICVarMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_ICVarMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^-;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    MC_CosThetaStar1Sol1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Sol1Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Sol1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Sol1Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Sol2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Sol2Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Sol2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Sol2Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    TH1::SetDefaultSumw2(kFALSE);
  }

  <font color="#228b22"><b>bool</b></font><b></b> MCPolPlots::Process(Event::Data &amp; ev) {
    <i><font color="#b22222">//the purpose of this class is to be able to look at cos theta* between a muon and virtual W, using the jet recoil (MHT)
</font></i>    <i><font color="#b22222">//as the substitute for W so we can look at a quantity we could measure from real data - and see what we'd expect from SUSY at MC level
</font></i>    <i><font color="#b22222">//that WAS the purpose of this class, now i'm using it as the closest estimate to the RECO plots using MC quantities. I only intend to run
</font></i>    <i><font color="#b22222">//over the ttbar and W samples so we can try to use this as a background estimation.
</font></i>
    GenMatrixBin myGenMatrixBin(&amp;ev);
    TLorentzVector jJetSum; 
    <b><font color="#a020f0">for</font></b>(<font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> i=0; i&lt;myGenMatrixBin.the_GenJets.size(); i++) {
      <i><font color="#b22222">//make the negative vector sum of all jets i.e. the MHT = W Pt - the pt&gt;30GeV cut is made in the GenMatrixBin. Make the |eta|&lt;3 cut here
</font></i>      <i><font color="#b22222">//if(fabs(myGenMatrixBin.the_GenJets.at(i)-&gt;Eta()) &lt; 3.0) jJetSum -= (*(myGenMatrixBin.the_GenJets.at(i)));
</font></i>      <b><font color="#a020f0">if</font></b>(fabs(myGenMatrixBin.the_GenJets.at(i)-&gt;Eta()) &lt; 3.0) jJetSum -= (TLVConvert(myGenMatrixBin.the_GenJets.at(i)));
      <i><font color="#b22222">//jJetSum -= (*(myGenMatrixBin.the_GenJets.at(i)));
</font></i>      <i><font color="#b22222">//now do it like we do in reco, with a pt and eta cut on the individual jets going into the sum
</font></i>      <i><font color="#b22222">//if(myGenMatrixBin.the_GenJets.at(i)-&gt;Pt() &gt; 30.0 &amp;&amp; fabs(myGenMatrixBin.the_GenJets.at(i)-&gt;Eta() &lt; 3.0) ) jJetSum2 -= (*(myGenMatrixBin.the_GenJets.at(i)));
</font></i>    }

    MC_MHT-&gt;Fill(jJetSum.Pt(), ev.GetEventWeight());
    MC_MuonMultiplicity-&gt;Fill(myGenMatrixBin.the_GenMuonExtra.size(), ev.GetEventWeight());
    MC_MuonEta-&gt;Fill(myGenMatrixBin.the_GenMuonExtra.at(0)-&gt;Eta(), ev.GetEventWeight());
    MC_MuonPt-&gt;Fill(myGenMatrixBin.the_GenMuonExtra.at(0)-&gt;Pt(), ev.GetEventWeight());
 
    <i><font color="#b22222">//jMCSol = FindBoost(*(myGenMatrixBin.the_GenMuonExtra.at(0)), jJetSum.Px(), jJetSum.Py(), 0.0, false);
</font></i>    jMCSol = FindBoost(TLVConvert(myGenMatrixBin.the_GenMuonExtra.at(0)), jJetSum.Px(), jJetSum.Py(), 0.0, false);
    <font color="#228b22"><b>double</b></font><b></b> ICVariable = ((myGenMatrixBin.the_GenMuonExtra.at(0)-&gt;Px() * jJetSum.Px()) + (myGenMatrixBin.the_GenMuonExtra.at(0)-&gt;Py() * jJetSum.Py())) / (jJetSum.Pt() * jJetSum.Pt());

    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) {
      MC_ICVarPlus-&gt;Fill(ICVariable, ev.GetEventWeight());
    }<b><font color="#a020f0">else</font></b>{
      MC_ICVarMinus-&gt;Fill(ICVariable, ev.GetEventWeight());
    }

    <b><font color="#a020f0">if</font></b>(jMCSol.realSolutions) {
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuonExtra.at(0)-&gt;GetID() &lt; 0) {
	MC_CosThetaStar1Sol1Plus-&gt;Fill(jMCSol.sol1, ev.GetEventWeight());
	MC_CosThetaStar1Sol2Plus-&gt;Fill(jMCSol.sol2, ev.GetEventWeight());
      }<b><font color="#a020f0">else</font></b>{
	MC_CosThetaStar1Sol1Minus-&gt;Fill(jMCSol.sol1, ev.GetEventWeight());
	MC_CosThetaStar1Sol2Minus-&gt;Fill(jMCSol.sol2, ev.GetEventWeight());
      }
    } <b><font color="#a020f0">else</font></b> {
      <i><font color="#b22222">//plot an "underflow" bin on these plots which will give an indication of the number of virtual solutions for each sample
</font></i>      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuonExtra.at(0)-&gt;GetID() &lt; 0) {
	MC_CosThetaStar1Sol1Plus-&gt;Fill(-1.2, ev.GetEventWeight());
	MC_CosThetaStar1Sol2Plus-&gt;Fill(-1.2, ev.GetEventWeight());
      }<b><font color="#a020f0">else</font></b>{
	MC_CosThetaStar1Sol1Minus-&gt;Fill(-1.2, ev.GetEventWeight());
	MC_CosThetaStar1Sol2Minus-&gt;Fill(-1.2, ev.GetEventWeight());
      }
    }

    <b><font color="#a020f0">return</font></b> true;
  }

  std::ostream&amp; MCPolPlots::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; <font color="#bc8f8f"><b>"Generator Polarisation plots"</b></font><b></b>;
    <b><font color="#a020f0">return</font></b> ostrm;
  }

  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// RECOPolPlots implementation 
</font></i>  <i><font color="#b22222">//====================================
</font></i>

  RECOPolPlots::RECOPolPlots(<font color="#228b22"><b>const</b></font><b></b> std::string &amp; folderName) :
    mFolderName(folderName) {}
   
  RECOPolPlots::~RECOPolPlots() {}

  <font color="#228b22"><b>void</b></font><b></b> RECOPolPlots::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  <font color="#228b22"><b>void</b></font><b></b> RECOPolPlots::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    RECO_MuonPtPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonPtPlus"</b></font><b></b>, <font color="#bc8f8f"><b>";#mu^{+} P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    RECO_MuonPtMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonPtMinus"</b></font><b></b>, <font color="#bc8f8f"><b>";#mu^{-} P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);
    RECO_MuonEtaPlus =  <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonEtaPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{+} #eta;Events / 100 pb^{-1}"</b></font><b></b>,100, -5.5, 4.5);
    RECO_MuonEtaMinus =  <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonEtaMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{-} #eta;Events / 100 pb^{-1}"</b></font><b></b>,100, -5.5, 4.5);
    RECO_MuonEtaPlusAbs =  <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonEtaPlusAbs"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{+} |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,100, -0.025, 4.975);
    RECO_MuonEtaMinusAbs =  <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonEtaMinusAbs"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu^{-} |#eta|;Events / 100 pb^{-1}"</b></font><b></b>,100, -0.025, 4.975);
    RECO_CommonMHTPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CommonMHTPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";Common MHT with mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    RECO_CommonMHTMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CommonMHTMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";Common MHT with mu^{-};Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    RECO_ICVarPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarMinus_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarMinus_LH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} LH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarPlus_LH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarPlus_LH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} LH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarMinus_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarMinus_RH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} RH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarPlus_RH = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarPlus_RH"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} RH;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarMinus_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarMinus_LO"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-} LO;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarPlus_LO = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarPlus_LO"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+} LO;Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarTCPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarTCPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarTCMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarTCMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarPFPlus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarPFPlus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarPFMinus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarPFMinus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarAK5Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarAK5Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarAK5Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarAK5Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarIC5Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarIC5Plus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{+};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_ICVarIC5Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_ICVarIC5Minus"</b></font><b></b>,<font color="#bc8f8f"><b>";IC Variable #mu^{-};Events / 100 pb^{-1}"</b></font><b></b>,500,-2.5,2.5);
    RECO_TransMass = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_TransMass"</b></font><b></b>,<font color="#bc8f8f"><b>";Transverse Mass [GeV];Events / 100 pb^{-1});"</b></font><b></b>,1000,-0.5,999.5);
    RECO_CommonMHT = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CommonMHT"</b></font><b></b>,<font color="#bc8f8f"><b>";Common MHT;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    RECO_MuonPt = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonPt"</b></font><b></b>, <font color="#bc8f8f"><b>";#mu P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000,-0.5,999.5);

    MC_MuonMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_MuonMultiplicity"</b></font><b></b>, <font color="#bc8f8f"><b>";genW Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    RECO_JetMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_JetMultiplicity"</b></font><b></b>,<font color="#bc8f8f"><b>";Common Jet Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>,20,-0.5,19.5);
    RECO_MuonMultiplicity = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_MuonMultiplicity"</b></font><b></b>, <font color="#bc8f8f"><b>";RECO Muon Multiplicity;Events / 100 pb^{-1}"</b></font><b></b>, 20,-0.5,19.5);
    MC_WPt = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPt"</b></font><b></b>, <font color="#bc8f8f"><b>";gen W P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 1000, -0.5, 999.5);
    MC_WYAbs = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WYAbs"</b></font><b></b>, <font color="#bc8f8f"><b>";gen W |Y|; Events / 100 pb^{-1}"</b></font><b></b>, 100, -0.025, 4.975);
    MC_CosThetaStar1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    MC_CosThetaStar1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CosThetaStar1Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    
    RECO_CosThetaStar1Sol1Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CosThetaStar1Sol1Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    RECO_CosThetaStar1Sol1Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CosThetaStar1Sol1Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    RECO_CosThetaStar1Sol2Plus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CosThetaStar1Sol2Plus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{+} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);
    RECO_CosThetaStar1Sol2Minus = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CosThetaStar1Sol2Minus"</b></font><b></b>, <font color="#bc8f8f"><b>";cos #theta^{*} from W^{-} ;Events / 100 pb^{-1}"</b></font><b></b>, 300,-1.5,1.5);

    MC_RECO_MuonMultMatch = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_MuonMultMatch"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu (MC, RECO) multiplicity match false/true;Events / 100 pb^{-1}"</b></font><b></b>,2,-0.5,1.5);
    MC_RECO_MHTDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_MHTDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC MHT;Events / 100 pb^{-1}"</b></font><b></b>, 2000, -1000.5, 999.5);
    MC_RECO_TCMETDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_TCMETDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC TCMET;Events / 100 pb^{-1}"</b></font><b></b>, 400, -20.5, 19.5);
    MC_RECO_PFMETDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_PFMETDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC PFMET;Events / 100 pb^{-1}"</b></font><b></b>, 400, -20.5, 19.5);
    MC_RECO_CaloMETDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_CaloMETDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC CaloMET;Events / 100 pb^{-1}"</b></font><b></b>, 400, -20.5, 19.5);
    MC_RECO_IC5METDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_IC5METDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC IC5MET;Events / 100 pb^{-1}"</b></font><b></b>, 400, -20.5, 19.5);
    MC_RECO_AK5METDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_AK5METDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC AK5MET;Events / 100 pb^{-1}"</b></font><b></b>, 400, -20.5, 19.5);

    MC_RECO_MuonPtDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_MuonPtDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO)/MC #muon P_{T};Events / 100 pb^{-1}"</b></font><b></b>, 2000, -1000.5, 999.5);
    MC_RECO_MuonEtaDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_MuonEtaDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#Delta (MC, RECO) #muon #eta;Events / 100 pb^{-1}"</b></font><b></b>, 200, -10.5, 9.5);
    MC_RECO_MuonChargeId = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_MuonChargeId"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,2,-0.5,1.5);

    RECO_Tr = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_TrIsoRel"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,200,-0.,10);
    RECO_Ecal = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_Ecal"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,200,-0.,10);
    RECO_Hcal = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_Hcal"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,200,-0.,10);
    RECO_Com = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_Com"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,200,-0.,10);
    RECO_DR = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_DR"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,200,-0.,10);
    RECO_Type = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_RECO_Type"</b></font><b></b>,<font color="#bc8f8f"><b>";#mu charge id wrong/right;Events / 100 pb^{-1}"</b></font><b></b>,10,-0.5,9.5);
    RECO_2ndMass = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"mass2muons"</b></font><b></b>,<font color="#bc8f8f"><b>";M_{#mu#mu};"</b></font><b></b>,1005,-5,1000);

    TH1::SetDefaultSumw2(kFALSE);

    RECO_MHTvsTCMET = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"RECO_MHTvsTCMET"</b></font><b></b>,<font color="#bc8f8f"><b>";MHT; TCMET"</b></font><b></b>,1000,-0.5,999.5,1000,-0.5,999.5);
    RECO_MHTvsCaloMET = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"RECO_MHTvsCaloMET"</b></font><b></b>,<font color="#bc8f8f"><b>";MHT; CaloMET"</b></font><b></b>,1000,-0.5,999.5,1000,-0.5,999.5);
    RECO_MHTvsPFMET = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"RECO_MHTvsPFMET"</b></font><b></b>,<font color="#bc8f8f"><b>";MHT; PFMET"</b></font><b></b>,1000,-0.5,999.5,1000,-0.5,999.5);
    RECO_MHTvsIC5MET = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"RECO_MHTvsIC5MET"</b></font><b></b>,<font color="#bc8f8f"><b>";MHT; IC5MET"</b></font><b></b>,1000,-0.5,999.5,1000,-0.5,999.5);
    RECO_MHTvsAK5MET = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"RECO_MHTvsAK5MET"</b></font><b></b>,<font color="#bc8f8f"><b>";MHT; AK5MET"</b></font><b></b>,1000,-0.5,999.5,1000,-0.5,999.5);
    MC_WPtY = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_WPtY"</b></font><b></b>,<font color="#bc8f8f"><b>";W P_{T}; W |Y|"</b></font><b></b>,1000,-0.5,999.5,  50,-0.05,4.95);

    MC_RECO_MHTDiffProfile = <b><font color="#a020f0">new</font></b> TProfile(<font color="#bc8f8f"><b>"MC_RECO_MHTDiffProfile"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T};#Delta (MC, RECO)/MC MHT"</b></font><b></b>,1000,-0.5,999.5,-20.5,19.5,<font color="#bc8f8f"><b>""</b></font><b></b>);

  }

  <font color="#228b22"><b>bool</b></font><b></b> RECOPolPlots::Process(Event::Data &amp; ev) {

    <i><font color="#b22222">// ******** SOME DEFINITIONS START ********
</font></i>
    <i><font color="#b22222">//the WPtResCut is for comparing the different MET resolutions vs the genW
</font></i>    <font color="#228b22"><b>double</b></font><b></b> WPtResCut = 100.0;
    GenMatrixBin myGenMatrixBin(&amp;ev);
    std::vector &lt;Event::GenObject <font color="#228b22"><b>const</b></font><b></b> *&gt; theGenLepton;
    std::vector &lt;Event::Lepton <font color="#228b22"><b>const</b></font><b></b> *&gt; theRECOLepton;

    <font color="#228b22"><b>bool</b></font><b></b> doGen = true; <i><font color="#b22222">//change this parameter ONLY - this will let you use comparison with generator level quantities
</font></i>
    <font color="#228b22"><b>bool</b></font><b></b> Wexists = false;
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.size() &gt; 0) Wexists = true;

    <i><font color="#b22222">//use GenInfo as variable to decide if we want to use generator level information
</font></i>    <font color="#228b22"><b>bool</b></font><b></b> GenInfo = false;
    <b><font color="#a020f0">if</font></b>(doGen &amp;&amp; Wexists) GenInfo = true;

    <i><font color="#b22222">//check that a reco lepton exists (only a muon in this case) otherwise return false safely
</font></i>    <b><font color="#a020f0">if</font></b>(ev.LD_CommonMuons().accepted.size()) theRECOLepton = ev.LD_CommonMuons().accepted;
    <b><font color="#a020f0">else</font></b> <b><font color="#a020f0">return</font></b> false;
      
    <i><font color="#b22222">// ******** SOME DEFINITIONS END ********
</font></i>


    <i><font color="#b22222">//for ICF ntuples only
</font></i>#<b><font color="#5f9ea0">ifdef</font></b> <font color="#b8860b">_ICF_</font>
    LorentzV tcMET, pfMET, ic5MET, ak5MET;
    tcMET = ev.TCMET() + *(theRECOLepton.at(0));
    pfMET = ev.PFMET() + *(theRECOLepton.at(0));
    ic5MET = ev.IC5MET() + *(theRECOLepton.at(0));
    ak5MET = ev.AK5MET() + *(theRECOLepton.at(0));
#<b><font color="#5f9ea0">endif</font></b>

    <i><font color="#b22222">//make the IC Variable at RECO level:
</font></i>    <font color="#228b22"><b>double</b></font><b></b> ICVariable = ((theRECOLepton.at(0)-&gt;Px() * ev.CommonMHT().Px()) + (theRECOLepton.at(0)-&gt;Py() * ev.CommonMHT().Py())) / (ev.CommonMHT().Pt() * ev.CommonMHT().Pt());
#<b><font color="#5f9ea0">ifdef</font></b> <font color="#b8860b">_ICF_</font>
    <font color="#228b22"><b>double</b></font><b></b> ICVariableTC = ((theRECOLepton.at(0)-&gt;Px() * tcMET.Px()) + (theRECOLepton.at(0)-&gt;Py() * tcMET.Py())) / (tcMET.Pt() * tcMET.Pt());
    <font color="#228b22"><b>double</b></font><b></b> ICVariablePF = ((theRECOLepton.at(0)-&gt;Px() * pfMET.Px()) + (theRECOLepton.at(0)-&gt;Py() * pfMET.Py())) / (pfMET.Pt() * pfMET.Pt());
    <font color="#228b22"><b>double</b></font><b></b> ICVariableIC5 = ((theRECOLepton.at(0)-&gt;Px() * ic5MET.Px()) + (theRECOLepton.at(0)-&gt;Py() * ic5MET.Py())) / (ic5MET.Pt() * ic5MET.Pt());
    <font color="#228b22"><b>double</b></font><b></b> ICVariableAK5 = ((theRECOLepton.at(0)-&gt;Px() * ak5MET.Px()) + (theRECOLepton.at(0)-&gt;Py() * ak5MET.Py())) / (ak5MET.Pt() * ak5MET.Pt());
#<b><font color="#5f9ea0">endif</font></b>

    <i><font color="#b22222">//to use MT, don't call CommonMT() - which is whack. Do the following:
</font></i>    <font color="#228b22"><b>double</b></font><b></b> eMT=ev.MT(theRECOLepton.at(0),&amp;(ev.CommonRecoilMET()));
    RECO_TransMass-&gt;Fill(eMT, ev.GetEventWeight());

    <b><font color="#a020f0">if</font></b>(GenInfo) {
      MC_WYAbs-&gt;Fill(fabs(myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity()), ev.GetEventWeight());
      MC_WPt-&gt;Fill(myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
      MC_WPtY-&gt;Fill(myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), fabs(myGenMatrixBin.the_GenW.at(0)-&gt;Rapidity()), ev.GetEventWeight()); 
      MC_MuonMultiplicity-&gt;Fill(myGenMatrixBin.the_GenMuon.size(), ev.GetEventWeight());
    }
      
    <i><font color="#b22222">//fill the Muon and MHT distributions according to charge
</font></i>    <b><font color="#a020f0">if</font></b>(theRECOLepton.at(0)-&gt;GetCharge()&gt;0.0) {
      RECO_MuonPtPlus-&gt;Fill(theRECOLepton.at(0)-&gt;Pt(), ev.GetEventWeight());
      RECO_MuonEtaPlus-&gt;Fill(theRECOLepton.at(0)-&gt;Eta(), ev.GetEventWeight());
      RECO_MuonEtaPlusAbs-&gt;Fill(fabs(theRECOLepton.at(0)-&gt;Eta()), ev.GetEventWeight());
      RECO_CommonMHTPlus-&gt;Fill(ev.CommonMHT().Pt(), ev.GetEventWeight());
      RECO_ICVarPlus-&gt;Fill(ICVariable, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(GenInfo) {
	<i><font color="#b22222">//now check that either a gen muon or gen tau exists - since we ask for a muon in the reco cutflow, it can only come from either of these gen particles
</font></i>	<b><font color="#a020f0">if</font></b>((myGenMatrixBin.the_GenMuon.size() &gt; 0 &amp;&amp; myGenMatrixBin.the_GenTau.size() == 0) || (myGenMatrixBin.the_GenMuon.size() == 0 &amp;&amp; myGenMatrixBin.the_GenTau.size() &gt; 0)) {
	  <i><font color="#b22222">//check that gen muon exists, or if it doesn't, a gen tau exists, and also it has the same charge as the reco muon
</font></i>	  <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size() &gt; 0) theGenLepton = myGenMatrixBin.the_GenMuon;
	  <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenTau.size() &gt; 0) theGenLepton = myGenMatrixBin.the_GenTau;

	  <b><font color="#a020f0">if</font></b>(theGenLepton.at(0)-&gt;GetID() &lt; 0) { 
	    jSolutionsW jMCSolution;
	    jGenW = TLVConvert(myGenMatrixBin.the_GenW.at(0));
	    jGenLep = TLVConvert(theGenLepton.at(0));
	    jMCSolution = FindBoost(jGenLep, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
	    <b><font color="#a020f0">if</font></b>(jMCSolution.realSolutions) {
	      <font color="#228b22"><b>int</b></font><b></b> index = <font color="#228b22"><b>int</b></font><b></b>( (jMCSolution.rightSol + 1.0) / 0.01 );
	      MC_CosThetaStar1Plus-&gt;Fill(jMCSolution.rightSol, ev.GetEventWeight());
	      RECO_ICVarPlus_LH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(jGenW.Pt(), jGenW.Rapidity(),index,true,0));
	      RECO_ICVarPlus_RH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(jGenW.Pt(), jGenW.Rapidity(),index,true,1));
	      RECO_ICVarPlus_LO-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(jGenW.Pt(), jGenW.Rapidity(),index,true,2));
	    }
	  }
	}
      }
#<b><font color="#5f9ea0">ifdef</font></b> <font color="#b8860b">_ICF_</font>
      <b><font color="#a020f0">if</font></b>(tcMET.Pt() &gt; METthresh) RECO_ICVarTCPlus-&gt;Fill(ICVariableTC, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(pfMET.Pt() &gt; METthresh) RECO_ICVarPFPlus-&gt;Fill(ICVariablePF, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(ic5MET.Pt() &gt; METthresh) RECO_ICVarIC5Plus-&gt;Fill(ICVariableIC5, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(ak5MET.Pt() &gt; METthresh) RECO_ICVarAK5Plus-&gt;Fill(ICVariableAK5, ev.GetEventWeight());
#<b><font color="#5f9ea0">endif</font></b>
    }<b><font color="#a020f0">else</font></b>{
      RECO_MuonPtMinus-&gt;Fill(theRECOLepton.at(0)-&gt;Pt(), ev.GetEventWeight());
      RECO_MuonEtaMinus-&gt;Fill(theRECOLepton.at(0)-&gt;Eta(), ev.GetEventWeight());
      RECO_MuonEtaMinusAbs-&gt;Fill(fabs(theRECOLepton.at(0)-&gt;Eta()), ev.GetEventWeight());
      RECO_CommonMHTMinus-&gt;Fill(ev.CommonMHT().Pt(), ev.GetEventWeight());
      RECO_ICVarMinus-&gt;Fill(ICVariable, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(GenInfo) {
	<b><font color="#a020f0">if</font></b>((myGenMatrixBin.the_GenMuon.size() &gt; 0 &amp;&amp; myGenMatrixBin.the_GenTau.size() == 0) || (myGenMatrixBin.the_GenMuon.size() == 0 &amp;&amp; myGenMatrixBin.the_GenTau.size() &gt; 0)) {
	  <i><font color="#b22222">//check that gen muon exists, or if it doesn't, a gen tau exists, and also it has the same charge as the reco muon
</font></i>	  <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size() &gt; 0) theGenLepton = myGenMatrixBin.the_GenMuon;
	  <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenTau.size() &gt; 0) theGenLepton = myGenMatrixBin.the_GenTau;

	  <b><font color="#a020f0">if</font></b>(theGenLepton.at(0)-&gt;GetID() &gt; 0) { 
	    jSolutionsW jMCSolution;
	    jGenW = TLVConvert(myGenMatrixBin.the_GenW.at(0));
	    jGenLep = TLVConvert(theGenLepton.at(0));
	    jMCSolution = FindBoost(jGenLep, jGenW.Px(), jGenW.Py(), jGenW.Pz(), true, false, jGenW.M());
	    <b><font color="#a020f0">if</font></b>(jMCSolution.realSolutions) {
	      <font color="#228b22"><b>int</b></font><b></b> index = <font color="#228b22"><b>int</b></font><b></b>( (jMCSolution.rightSol + 1.0) / 0.01 );
	      MC_CosThetaStar1Minus-&gt;Fill(jMCSolution.rightSol, ev.GetEventWeight());
	      RECO_ICVarMinus_LH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(jGenW.Pt(), jGenW.Rapidity(),index,false,0));
	      RECO_ICVarMinus_RH-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(jGenW.Pt(), jGenW.Rapidity(),index,false,1));
	      RECO_ICVarMinus_LO-&gt;Fill(ICVariable, ev.GetEventWeight() * CorrFactor(jGenW.Pt(), jGenW.Rapidity(),index,false,2));
	    }
	  }
	}
      }
#<b><font color="#5f9ea0">ifdef</font></b> <font color="#b8860b">_ICF_</font>
      <b><font color="#a020f0">if</font></b>(tcMET.Pt() &gt; METthresh) RECO_ICVarTCMinus-&gt;Fill(ICVariableTC, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(pfMET.Pt() &gt; METthresh) RECO_ICVarPFMinus-&gt;Fill(ICVariablePF, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(ic5MET.Pt() &gt; METthresh) RECO_ICVarIC5Minus-&gt;Fill(ICVariableIC5, ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(ak5MET.Pt() &gt; METthresh) RECO_ICVarAK5Minus-&gt;Fill(ICVariableAK5, ev.GetEventWeight());
#<b><font color="#5f9ea0">endif</font></b>
    }

    RECO_CommonMHT-&gt;Fill(ev.CommonMHT().Pt(), ev.GetEventWeight());
    RECO_MuonPt-&gt;Fill(theRECOLepton.at(0)-&gt;Pt(), ev.GetEventWeight());
    RECO_JetMultiplicity-&gt;Fill(ev.JD_CommonJets().accepted.size(), ev.GetEventWeight());
    RECO_MuonMultiplicity-&gt;Fill(theRECOLepton.size(), ev.GetEventWeight());

    RECO_Tr-&gt;Fill(theRECOLepton.at(0)-&gt;GetTrkIsolation() /theRECOLepton.at(0)-&gt;Pt(), ev.GetEventWeight());
    RECO_Ecal-&gt;Fill(theRECOLepton.at(0)-&gt;GetEcalIsolation() /theRECOLepton.at(0)-&gt;Pt(), ev.GetEventWeight());
    RECO_Hcal-&gt;Fill(theRECOLepton.at(0)-&gt;GetCombIsolation() /theRECOLepton.at(0)-&gt;Pt(), ev.GetEventWeight());
    RECO_Com-&gt;Fill(theRECOLepton.at(0)-&gt;GetCombIsolation(), ev.GetEventWeight());
    RECO_Type-&gt;Fill(theRECOLepton.at(0)-&gt;GetType(), ev.GetEventWeight());

    <font color="#228b22"><b>float</b></font><b></b> minDeltaR = 20;
    <b><font color="#a020f0">for</font></b> ( <font color="#228b22"><b>unsigned</b></font><b></b> <font color="#228b22"><b>int</b></font><b></b> i=0; i&lt; ev.JD_CommonJets().accepted.size(); i++ ) {
      <b><font color="#a020f0">if</font></b> (i == 0) minDeltaR = fabs(ROOT::Math::VectorUtil::DeltaR (*(ev.JD_CommonJets().accepted.at(i)),*(theRECOLepton.at(0))));
      <b><font color="#a020f0">else</font></b> {
	<b><font color="#a020f0">if</font></b>(fabs(ROOT::Math::VectorUtil::DeltaR (*(ev.JD_CommonJets().accepted.at(i)),*(theRECOLepton.at(0)))) &lt; minDeltaR) minDeltaR = fabs(ROOT::Math::VectorUtil::DeltaR (*(ev.JD_CommonJets().accepted.at(i)),*(theRECOLepton.at(0))));

      }
    }
    RECO_DR-&gt;Fill(minDeltaR, ev.GetEventWeight());

    <font color="#228b22"><b>float</b></font><b></b> Zmass = 0.0;
    <b><font color="#a020f0">if</font></b>(ev.LD_Muons().size()&gt;1) {

      <b><font color="#a020f0">for</font></b> (std::vector&lt;Event::Lepton&gt;::const_iterator imu = ev.LD_Muons().begin();  imu != ev.LD_Muons().end();++imu) {
	<font color="#228b22"><b>float</b></font><b></b> ZmassCurrent = ROOT::Math::VectorUtil::InvariantMass(*imu,*(theRECOLepton.at(0)));
	<b><font color="#a020f0">if</font></b> (Zmass==0.0) Zmass=ZmassCurrent;
	<b><font color="#a020f0">if</font></b>(fabs(ZmassCurrent-91.2) &lt; (fabs(Zmass-91.2)))  Zmass=ZmassCurrent;
      }
    }
    RECO_2ndMass-&gt;Fill(Zmass,ev.GetEventWeight());

    <b><font color="#a020f0">if</font></b>(GenInfo) {
      <i><font color="#b22222">//check how many times real MC muon exists for RECO muon and when this happens, check the charge identification and the pt and eta widths
</font></i>      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size() == theRECOLepton.size()) {
	MC_RECO_MuonMultMatch-&gt;Fill(1.0, ev.GetEventWeight());
	<b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.size() &gt; 0) {
	  MC_RECO_MHTDiffProfile-&gt;Fill(myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), (myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - ev.CommonMHT().Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
	  <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.at(0)-&gt;Pt() &gt; WPtResCut) {
	    MC_RECO_MHTDiff-&gt;Fill((myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - ev.CommonMHT().Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
	    MC_RECO_CaloMETDiff-&gt;Fill((myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - ev.CaloMET().Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());

	    <i><font color="#b22222">//to ensure compatibility
</font></i>#<b><font color="#5f9ea0">ifdef</font></b> <font color="#b8860b">_ICF_</font>
	    MC_RECO_TCMETDiff-&gt;Fill((myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - tcMET.Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
	    MC_RECO_PFMETDiff-&gt;Fill((myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - pfMET.Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
	    MC_RECO_IC5METDiff-&gt;Fill((myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - ic5MET.Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
	    MC_RECO_AK5METDiff-&gt;Fill((myGenMatrixBin.the_GenW.at(0)-&gt;Pt() - ak5MET.Pt())/myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());

	    RECO_MHTvsTCMET-&gt;Fill(ev.CommonMHT().Pt(), tcMET.Pt(), ev.GetEventWeight());
	    RECO_MHTvsPFMET-&gt;Fill(ev.CommonMHT().Pt(), pfMET.Pt(), ev.GetEventWeight());
	    RECO_MHTvsCaloMET-&gt;Fill(ev.CommonMHT().Pt(), ev.CaloMET().Pt(), ev.GetEventWeight());
	    RECO_MHTvsAK5MET-&gt;Fill(ev.CommonMHT().Pt(), ak5MET.Pt(), ev.GetEventWeight());
	    RECO_MHTvsIC5MET-&gt;Fill(ev.CommonMHT().Pt(), ic5MET.Pt(), ev.GetEventWeight());
#<b><font color="#5f9ea0">endif</font></b>
	  }
	}
	MC_RECO_MuonPtDiff-&gt;Fill((myGenMatrixBin.the_GenMuon.at(0)-&gt;Pt() - theRECOLepton.at(0)-&gt;Pt())/myGenMatrixBin.the_GenMuon.at(0)-&gt;Pt(), ev.GetEventWeight());
	MC_RECO_MuonEtaDiff-&gt;Fill((myGenMatrixBin.the_GenMuon.at(0)-&gt;Eta() - theRECOLepton.at(0)-&gt;Eta()), ev.GetEventWeight());
      
	<i><font color="#b22222">//remember that a negatively charge muon has a positive ID and vice versa
</font></i>	<b><font color="#a020f0">if</font></b>((myGenMatrixBin.the_GenMuon.at(0)-&gt;GetID() &gt; 0 &amp;&amp; theRECOLepton.at(0)-&gt;GetCharge() &lt; 0) || (myGenMatrixBin.the_GenMuon.at(0)-&gt;GetID() &lt; 0 &amp;&amp; theRECOLepton.at(0)-&gt;GetCharge() &gt; 0)) MC_RECO_MuonChargeId-&gt;Fill(1.0, ev.GetEventWeight());
	<b><font color="#a020f0">else</font></b> MC_RECO_MuonChargeId-&gt;Fill(0.0, ev.GetEventWeight());
    
      } <b><font color="#a020f0">else</font></b> {
	MC_RECO_MuonMultMatch-&gt;Fill(0.0, ev.GetEventWeight());
      }
    }

    <i><font color="#b22222">//now fill the cos theta star distributions - first check for real solutions
</font></i>    <i><font color="#b22222">//jRECOSol = FindBoost(*(theRECOLepton.at(0)), ev.CommonMHT().Px(), ev.CommonMHT().Py(), 0.0, false);
</font></i>    jRECOSol = FindBoost(TLVConvert(theRECOLepton.at(0)), ev.CommonMHT().Px(), ev.CommonMHT().Py(), 0.0, false);

    <b><font color="#a020f0">if</font></b>(jRECOSol.realSolutions) {
      <b><font color="#a020f0">if</font></b>(theRECOLepton.at(0)-&gt;GetCharge()&gt;0.0) {
	RECO_CosThetaStar1Sol1Plus-&gt;Fill(jRECOSol.sol1, ev.GetEventWeight());
	RECO_CosThetaStar1Sol2Plus-&gt;Fill(jRECOSol.sol2, ev.GetEventWeight());
      }<b><font color="#a020f0">else</font></b>{
	RECO_CosThetaStar1Sol1Minus-&gt;Fill(jRECOSol.sol1, ev.GetEventWeight());
	RECO_CosThetaStar1Sol2Minus-&gt;Fill(jRECOSol.sol2, ev.GetEventWeight());
      }
    } <b><font color="#a020f0">else</font></b> {
      <i><font color="#b22222">//plot an "underflow" bin on these plots which will give an indication of the number of virtual solutions for each sample
</font></i>      <b><font color="#a020f0">if</font></b>(theRECOLepton.at(0)-&gt;GetCharge()&gt;0.0) {
	RECO_CosThetaStar1Sol1Plus-&gt;Fill(-1.2, ev.GetEventWeight());
	RECO_CosThetaStar1Sol2Plus-&gt;Fill(-1.2, ev.GetEventWeight());
      }<b><font color="#a020f0">else</font></b>{
	RECO_CosThetaStar1Sol1Minus-&gt;Fill(-1.2, ev.GetEventWeight());
	RECO_CosThetaStar1Sol2Minus-&gt;Fill(-1.2, ev.GetEventWeight());
      }
    }

    <b><font color="#a020f0">return</font></b> true;
  }


  std::ostream&amp; RECOPolPlots::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; <font color="#bc8f8f"><b>"Reco Level Polarisation plots"</b></font><b></b>;
    <b><font color="#a020f0">return</font></b> ostrm;
  }


  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// MC7to10 implementation
</font></i>  <i><font color="#b22222">//====================================
</font></i>
  MC7to10::MC7to10(<font color="#228b22"><b>const</b></font><b></b> std::string &amp; folderName) :
    mFolderName(folderName) {}

  MC7to10::~MC7to10() {}

  <font color="#228b22"><b>void</b></font><b></b> MC7to10::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  <font color="#228b22"><b>void</b></font><b></b> MC7to10::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    MC_WPtMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPtMuonAcc"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} given muon acceptance;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_WPtPlusMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPtPlusMuonAcc"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} given muon acceptance;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    MC_WPtMinusMuonAcc = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_WPtMinusMuonAcc"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} given muon acceptance;Events / 100 pb^{-1}"</b></font><b></b>,1000,-0.5,999.5);
    TH1::SetDefaultSumw2(kFALSE);
  }

  <font color="#228b22"><b>bool</b></font><b></b> MC7to10::Process(Event::Data &amp; ev) {
    <i><font color="#b22222">//already check that genW exists and decays to a muon
</font></i>    GenMatrixBin myGenMatrixBin(&amp;ev);
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.at(0)-&gt;Pt() &gt; 15.0 &amp;&amp; fabs(myGenMatrixBin.the_GenMuon.at(0)-&gt;Eta()) &lt; 2.1) {
      MC_WPtMuonAcc-&gt;Fill(myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.at(0)-&gt;GetID() &gt; 0) MC_WPtPlusMuonAcc-&gt;Fill(myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
      <b><font color="#a020f0">else</font></b> MC_WPtMinusMuonAcc-&gt;Fill(myGenMatrixBin.the_GenW.at(0)-&gt;Pt(), ev.GetEventWeight());
    }
    <b><font color="#a020f0">return</font></b> true;
  }

  std::ostream&amp; MC7to10::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; <font color="#bc8f8f"><b>"MC 7 to 10 TeV Sanity check plots"</b></font><b></b>;
    <b><font color="#a020f0">return</font></b> ostrm;
  }

  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// MCCSFramePlots implementation
</font></i>  <i><font color="#b22222">//====================================
</font></i><i><font color="#b22222">/*
  double MCCSFramePlots::numerator=0.0;
  double MCCSFramePlots::denominator=0.0;

  double &amp; MCCSFramePlots::Numerator() {
    static double lNumerator=0.0;
    return lNumerator;
  }

  double &amp; MCCSFramePlots::Denominator() {
    static double lDenominator=0.0;
    return lDenominator;
  }
*/</font></i>

  MCCSFramePlots::MCCSFramePlots(<font color="#228b22"><b>const</b></font><b></b> std::string &amp; folderName) :
    mFolderName(folderName) {}

  MCCSFramePlots::~MCCSFramePlots() {
    <i><font color="#b22222">//std::cout &lt;&lt; "numerator: " &lt;&lt; Numerator() &lt;&lt; ", denominator: " &lt;&lt; Denominator() &lt;&lt; std::endl;
</font></i>    <i><font color="#b22222">//MC_CSWAiNumerator-&gt;Divide();
</font></i>  }

  <font color="#228b22"><b>void</b></font><b></b> MCCSFramePlots::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  <font color="#228b22"><b>void</b></font><b></b> MCCSFramePlots::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    MC_CSWMuonPlusPhi = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMuonPlusPhi"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{+} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-3.55,3.45);
    MC_CSWMuonPlusPhi2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMuonPlusPhi2"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{+} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-0.05,6.95);
    MC_CSWMuonMinusPhi = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMuonMinusPhi"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-3.55,3.45);
    MC_CSWMuonMinusPhi2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMuonMinusPhi2"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-0.05,6.95);
    MC_CSWMuonPlusCosTheta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMuonPlusCosTheta"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} cos#theta in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,200,-1.05,0.95);
    MC_CSWMuonMinusCosTheta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMuonMinusCosTheta"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} cos#theta in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,200,-1.05,0.95);

    MC_CSWA0Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWA0Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} [GeV];A_{0} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWA1Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWA1Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} [GeV];A_{1} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWA2Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWA2Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} [GeV];A_{2} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWA3Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWA3Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} [GeV];A_{3} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWA4Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWA4Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} [GeV];A_{4} Numerator"</b></font><b></b>,1000,-0.5,999.5);

    MC_CSWPlusA0Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPlusA0Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} [GeV];A_{0} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWPlusA1Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPlusA1Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} [GeV];A_{1} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWPlusA2Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPlusA2Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} [GeV];A_{2} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWPlusA3Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPlusA3Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} [GeV];A_{3} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWPlusA4Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPlusA4Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} [GeV];A_{4} Numerator"</b></font><b></b>,1000,-0.5,999.5);

    MC_CSWMinusA0Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMinusA0Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} [GeV];A_{0} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWMinusA1Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMinusA1Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} [GeV];A_{1} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWMinusA2Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMinusA2Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} [GeV];A_{2} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWMinusA3Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMinusA3Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} [GeV];A_{3} Numerator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWMinusA4Numerator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMinusA4Numerator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} [GeV];A_{4} Numerator"</b></font><b></b>,1000,-0.5,999.5);

    MC_CSWPlusAiDenominator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPlusAiDenominator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{+} P_{T} [GeV];A_{i} Denominator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWMinusAiDenominator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWMinusAiDenominator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W^{-} P_{T} [GeV];A_{i} Denominator"</b></font><b></b>,1000,-0.5,999.5);
    MC_CSWAiDenominator = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWAiDenominator"</b></font><b></b>,<font color="#bc8f8f"><b>";gen W P_{T} [GeV];A_{i} Denominator"</b></font><b></b>,1000,-0.5,999.5);

    MC_CSWPzSol1PhiDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPzSol1PhiDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#phi_{true} - #phi_{Sol1};Events / 10 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_CSWPzSol2PhiDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPzSol2PhiDiff"</b></font><b></b>,<font color="#bc8f8f"><b>";#phi_{true} - #phi_{Sol2};Events / 10 pb^{-1}"</b></font><b></b>,100,-5.5,4.5);
    MC_CSWPzDiff = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"MC_CSWPzDiff"</b></font><b></b>, <font color="#bc8f8f"><b>";#nu P_{z}^{true} - P_{z}^{formula}"</b></font><b></b>,100,-5.5,4.5);
    TH1::SetDefaultSumw2(kFALSE);
    MC_CSWM_WMT = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_CSWM_WMT"</b></font><b></b>,<font color="#bc8f8f"><b>";W mass; W transverse mass"</b></font><b></b>,100,49.5,99.5,100,49.5,99.5);
  }

  <font color="#228b22"><b>bool</b></font><b></b> MCCSFramePlots::Process(Event::Data &amp; ev) {
    <i><font color="#b22222">//already check that genW exists and decays to a muon/lepton
</font></i>    GenMatrixBin myGenMatrixBin(&amp;ev);

    <font color="#228b22"><b>bool</b></font><b></b> forW=true;
    vector &lt;Event::GenObject <font color="#228b22"><b>const</b></font><b></b> *&gt; theVBosons;
    Event::GenObject <font color="#228b22"><b>const</b></font><b></b> * genLepton;
    Event::GenObject <font color="#228b22"><b>const</b></font><b></b> * genLeptonNu;
    <i><font color="#b22222">//the next statement is used so that we can change definitions in the future without affecting the code
</font></i>    <b><font color="#a020f0">if</font></b>(forW) { 
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.size()==0) <b><font color="#a020f0">return</font></b> false;
      theVBosons = myGenMatrixBin.the_GenW;
      <i><font color="#b22222">//w.SetXYZM(theVBosons.at(0)-&gt;Px(),theVBosons.at(0)-&gt;Py(),theVBosons.at(0)-&gt;Pz(),theVBosons.at(0)-&gt;M());
</font></i>      <i><font color="#b22222">//we can make the below statements with confidence if we use the MCWLeptonExists cut which checks explicitly that the W decays to (one) lepton
</font></i>      <i><font color="#b22222">//and of course if we want to reproduce the muon plots, select to use MCWMuonExists (and similarly for other leptons...)
</font></i>      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenEli.size()) {
	genLepton = myGenMatrixBin.the_GenEli.at(0);
	genLeptonNu = myGenMatrixBin.the_GenEliNu.at(0);
      }
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size()) {
	genLepton = myGenMatrixBin.the_GenMuon.at(0);
	genLeptonNu = myGenMatrixBin.the_GenMuonNu.at(0);
      }
      <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenTau.size()) {
	genLepton = myGenMatrixBin.the_GenTau.at(0);
	genLeptonNu = myGenMatrixBin.the_GenTauNu.at(0);
      }
    }

    TLorentzVector lepton;
    TLorentzVector neutrino;
    lepton = CSTransform( TLVConvert(genLepton), TLVConvert(theVBosons.at(0)));
    neutrino = CSTransform( TLVConvert(genLeptonNu), TLVConvert(theVBosons.at(0)));

    <i><font color="#b22222">//work out the neutrino pz using the four-vector algebra. Do this first with the proper gen level W-boson mass
</font></i>    <i><font color="#b22222">//this is so we can check the effects of taking the positive and negative root have on phi - it should be independent...
</font></i>    <font color="#228b22"><b>double</b></font><b></b> constantA = (theVBosons.at(0)-&gt;M2()) + (theVBosons.at(0)-&gt;Perp2()) - (genLepton-&gt;Perp2()) - (genLeptonNu-&gt;Perp2()) - (genLepton-&gt;M2()) - (genLeptonNu-&gt;M2());
    <font color="#228b22"><b>double</b></font><b></b> constantB = (constantA * constantA) - (4.0 * (genLepton-&gt;Perp2() + genLepton-&gt;M2()) * (genLeptonNu-&gt;Perp2() + genLeptonNu-&gt;M2()));
    <font color="#228b22"><b>double</b></font><b></b> constantC = (2.0 * (genLepton-&gt;Perp2() + genLepton-&gt;M2())); <i><font color="#b22222">//paper says 4.0, i think 2.0 - let's see... it's 2.0! hehe
</font></i>    <font color="#228b22"><b>double</b></font><b></b> constantD = ((constantA * genLepton-&gt;Pz()) / constantC);
    <font color="#228b22"><b>double</b></font><b></b> constantE = ((genLepton-&gt;E() * sqrt(constantB)) / constantC);
    <i><font color="#b22222">//these solutions are the pz of the neutrino:
</font></i>    <font color="#228b22"><b>double</b></font><b></b> pzsol1 = (constantD + constantE);
    <font color="#228b22"><b>double</b></font><b></b> pzsol2 = (constantD - constantE);

    <font color="#228b22"><b>double</b></font><b></b> diff;
    <b><font color="#a020f0">if</font></b>(fabs(pzsol1 - genLeptonNu-&gt;Pz()) &lt; fabs(pzsol2 - genLeptonNu-&gt;Pz())) {
      MC_CSWPzDiff-&gt;Fill(pzsol1 - genLeptonNu-&gt;Pz(), ev.GetEventWeight());
      diff = pzsol1 - genLeptonNu-&gt;Pz();
    }<b><font color="#a020f0">else</font></b>{
      MC_CSWPzDiff-&gt;Fill(pzsol2 - genLeptonNu-&gt;Pz(), ev.GetEventWeight());
      diff = pzsol2 - genLeptonNu-&gt;Pz();
    }
<i><font color="#b22222">/*
//some diagnostics in case things go wrong
std::cout &lt;&lt; "Diagnostics: " &lt;&lt; std::endl;
std::cout &lt;&lt; "diff: " &lt;&lt; diff &lt;&lt; std::endl;
std::cout &lt;&lt; "discriminant = " &lt;&lt; constantB &lt;&lt; std::endl;
std::cout &lt;&lt; "constantA = " &lt;&lt; constantA &lt;&lt; std::endl;

std::cout &lt;&lt; "E_lepton = " &lt;&lt; genLepton-&gt;E() &lt;&lt; std::endl;
std::cout &lt;&lt; "pz_lepton = " &lt;&lt; genLepton-&gt;Pz() &lt;&lt; std::endl;
std::cout &lt;&lt; "pt_lepton = " &lt;&lt; genLepton-&gt;Pt() &lt;&lt; std::endl;
std::cout &lt;&lt; "mass_lepton = " &lt;&lt; genLepton-&gt;M() &lt;&lt; std::endl;

std::cout &lt;&lt; "E_neutrino = " &lt;&lt; genLeptonNu-&gt;E() &lt;&lt; std::endl;
std::cout &lt;&lt; "pz_neutrino = " &lt;&lt; genLeptonNu-&gt;Pz() &lt;&lt; std::endl;
std::cout &lt;&lt; "pt_neutrino = " &lt;&lt; genLeptonNu-&gt;Pt() &lt;&lt; std::endl;
std::cout &lt;&lt; "mass_neutrino = " &lt;&lt; genLeptonNu-&gt;M() &lt;&lt; std::endl;

std::cout &lt;&lt; "E_W = " &lt;&lt; theVBosons.at(0)-&gt;E() &lt;&lt; std::endl;
std::cout &lt;&lt; "pz_W = " &lt;&lt; theVBosons.at(0)-&gt;Pz() &lt;&lt; std::endl;
std::cout &lt;&lt; "pt_W = " &lt;&lt; theVBosons.at(0)-&gt;Pt() &lt;&lt; std::endl;
std::cout &lt;&lt; "mass_W = " &lt;&lt; theVBosons.at(0)-&gt;M() &lt;&lt; std::endl;

std::cout &lt;&lt; "Actual pz_neutrino: " &lt;&lt; genLeptonNu-&gt;Pz() &lt;&lt; std::endl; 
std::cout &lt;&lt; "sanity check 1: lepton + lepton neutrino - W (Px,Py,Pz): ("
&lt;&lt; genLepton-&gt;Px() + genLeptonNu-&gt;Px() - theVBosons.at(0)-&gt;Px() &lt;&lt; ", "
&lt;&lt; genLepton-&gt;Py() + genLeptonNu-&gt;Py() - theVBosons.at(0)-&gt;Py() &lt;&lt; ", "
&lt;&lt; genLepton-&gt;Pz() + genLeptonNu-&gt;Pz() - theVBosons.at(0)-&gt;Pz() &lt;&lt; ") " &lt;&lt; std::endl;
TLorentzVector tlv_lepton = TLVConvert(genLepton);
TLorentzVector tlv_neutrino = TLVConvert(genLeptonNu);
std::cout &lt;&lt; "sanity check 2: (lepton + lepton neutrino)^2 : " &lt;&lt; (tlv_lepton+tlv_neutrino).M() &lt;&lt; std::endl;
std::cout &lt;&lt; "sanity check 3: 2* (lepton -dot- lepton neutrino) : " &lt;&lt; 2*tlv_lepton.Dot(tlv_neutrino) &lt;&lt; std::endl;
std::cout &lt;&lt; std::endl;
*/</font></i>
    <i><font color="#b22222">//need to correct for the pz of the lepton so that we get the pz of the W:
</font></i>    pzsol1 += genLepton-&gt;Pz();
    pzsol2 += genLepton-&gt;Pz();

    <i><font color="#b22222">//double pzsol1 = genLepton-&gt;Pz() + genLeptonNu-&gt;Pz(); //as a test of the method
</font></i>    TLorentzVector wvector_pzsol1;
    TLorentzVector wvector_pzsol2;
    wvector_pzsol1.SetXYZM(theVBosons.at(0)-&gt;Px(), theVBosons.at(0)-&gt;Py(), pzsol1, theVBosons.at(0)-&gt;M());
    wvector_pzsol2.SetXYZM(theVBosons.at(0)-&gt;Px(), theVBosons.at(0)-&gt;Py(), pzsol2, theVBosons.at(0)-&gt;M());
    TLorentzVector lepton_pzsol1 = CSTransform( TLVConvert(genLepton), wvector_pzsol1);
    TLorentzVector lepton_pzsol2 = CSTransform( TLVConvert(genLepton), wvector_pzsol2);
    MC_CSWPzSol1PhiDiff-&gt;Fill(lepton_pzsol1.Phi() - lepton.Phi(), ev.GetEventWeight());
    MC_CSWPzSol2PhiDiff-&gt;Fill(lepton_pzsol2.Phi() - lepton.Phi(), ev.GetEventWeight());

    <font color="#228b22"><b>double</b></font><b></b> adjusted_phi=0.0;
    <i><font color="#b22222">//add 2Pi to the negative values of Phi to take it from [-pi,+pi] to [0,2pi]
</font></i>    <b><font color="#a020f0">if</font></b>(lepton.Phi()&lt;0.0) adjusted_phi = ((2.0*TMath::Pi()) + lepton.Phi());
    <b><font color="#a020f0">else</font></b> adjusted_phi = lepton.Phi();

    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
      MC_CSWMuonPlusPhi-&gt;Fill(lepton.Phi(), ev.GetEventWeight());
      MC_CSWMuonPlusPhi2-&gt;Fill(adjusted_phi, ev.GetEventWeight());
      MC_CSWMuonPlusCosTheta-&gt;Fill(lepton.CosTheta(), ev.GetEventWeight());
    } <b><font color="#a020f0">else</font></b> { 
      MC_CSWMuonMinusPhi-&gt;Fill(lepton.Phi(), ev.GetEventWeight());
      MC_CSWMuonMinusPhi2-&gt;Fill(adjusted_phi, ev.GetEventWeight());
      MC_CSWMuonMinusCosTheta-&gt;Fill(lepton.CosTheta(), ev.GetEventWeight());
    }

    <i><font color="#b22222">//to plot the transverse mass of the W (with the lepton,neutrino pair) vs the true W mass:
</font></i>    <font color="#228b22"><b>double</b></font><b></b> w_mtrans = sqrt(2.0*neutrino.Pt()*lepton.Pt()*(1.0 - cos(lepton.DeltaPhi(neutrino))));
    MC_CSWM_WMT-&gt;Fill(theVBosons.at(0)-&gt;M(), w_mtrans, ev.GetEventWeight());

    <i><font color="#b22222">//in these plots, we actually want the value of numerator/denominator, where in num and denom, there is a sum over all events
</font></i>    <i><font color="#b22222">//since we want them binned in Wpt, we fill the pt of the W with weight according to the contents of the sum
</font></i>    <i><font color="#b22222">//then afterward, you divide the two histograms...
</font></i>    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
      MC_CSWMinusA4Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), lepton.CosTheta() *ev.GetEventWeight());
      MC_CSWMinusA3Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), cos(lepton.Phi()) * sin(lepton.Theta()) * ev.GetEventWeight());
      MC_CSWMinusA2Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), sin(lepton.Theta()) * sin(lepton.Theta()) * cos(2.0*lepton.Phi()) * ev.GetEventWeight());
      MC_CSWMinusA1Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), cos(lepton.Phi()) * sin(2.0*lepton.Theta()) * ev.GetEventWeight());
      MC_CSWMinusA0Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), 0.5*(1.0-3.0*lepton.CosTheta()*lepton.CosTheta()) * ev.GetEventWeight());
      MC_CSWMinusAiDenominator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
    } <b><font color="#a020f0">else</font></b> {
      MC_CSWPlusA4Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), lepton.CosTheta() * ev.GetEventWeight());
      MC_CSWPlusA3Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), cos(lepton.Phi()) * sin(lepton.Theta()) * ev.GetEventWeight());
      MC_CSWPlusA2Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), sin(lepton.Theta()) * sin(lepton.Theta()) * cos(2.0*lepton.Phi()) * ev.GetEventWeight());
      MC_CSWPlusA1Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), cos(lepton.Phi()) * sin(2.0*lepton.Theta()) * ev.GetEventWeight());
      MC_CSWPlusA0Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), 0.5*(1.0-3.0*lepton.CosTheta()*lepton.CosTheta()) * ev.GetEventWeight());
      MC_CSWPlusAiDenominator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());
    }

    MC_CSWA4Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), lepton.CosTheta() * ev.GetEventWeight());
    MC_CSWA3Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), cos(lepton.Phi()) * sin(lepton.Theta()) * ev.GetEventWeight());
    MC_CSWA2Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), sin(lepton.Theta()) * sin(lepton.Theta()) * cos(2.0*lepton.Phi()) * ev.GetEventWeight());
    MC_CSWA1Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), cos(lepton.Phi()) * sin(2.0*lepton.Theta()) * ev.GetEventWeight());
    MC_CSWA0Numerator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), 0.5*(1.0-3.0*lepton.CosTheta()*lepton.CosTheta()) * ev.GetEventWeight());
    MC_CSWAiDenominator-&gt;Fill(theVBosons.at(0)-&gt;Pt(), ev.GetEventWeight());


    <b><font color="#a020f0">return</font></b> true;
  }

  std::ostream&amp; MCCSFramePlots::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; <font color="#bc8f8f"><b>"MC Collins-Soper Frame Plots"</b></font><b></b>;
    <b><font color="#a020f0">return</font></b> ostrm;
  }

  <i><font color="#b22222">//====================================
</font></i>  <i><font color="#b22222">// RECOCSFramePlots implementation
</font></i>  <i><font color="#b22222">//====================================
</font></i>  RECOCSFramePlots::RECOCSFramePlots(<font color="#228b22"><b>const</b></font><b></b> std::string &amp; folderName) :
    mFolderName(folderName) {}

  RECOCSFramePlots::~RECOCSFramePlots() {}

  <font color="#228b22"><b>void</b></font><b></b> RECOCSFramePlots::Start(Event::Data &amp; ev) {
    initDir(ev.OutputFile(), mFolderName.c_str());
    BookHistos();
  }

  <font color="#228b22"><b>void</b></font><b></b> RECOCSFramePlots::BookHistos() {
    TH1::SetDefaultSumw2(kTRUE);
    RECO_CSWMuonPlusPhi = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuonPlusPhi"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{+} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-3.55,3.45);
    RECO_CSWMuonPlusPhi2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuonPlusPhi2"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{+} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-0.05,6.95);
    RECO_CSWMuonMinusPhi = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuonMinusPhi"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-3.55,3.45);
    RECO_CSWMuonMinusPhi2 = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuonMinusPhi2"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-0.05,6.95);
    RECO_CSWMuonPlusCosTheta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuonPlusCosTheta"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{+} cos#theta in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,200,-1.05,0.95);
    RECO_CSWMuonMinusCosTheta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuonMinusCosTheta"</b></font><b></b>,<font color="#bc8f8f"><b>";gen #mu^{-} cos#theta in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,200,-1.05,0.95);
    RECO_CSWTransMass = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWTransMass"</b></font><b></b>, <font color="#bc8f8f"><b>";W Transverse Mass [GeV/c^{2}]; Events / 10 pb^{-1}"</b></font><b></b>, 200, -0.5, 199.5);

    RECO_CSWMuon2PlusPhi = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuon2PlusPhi"</b></font><b></b>,<font color="#bc8f8f"><b>";RECO #mu^{+} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-3.55,3.45);
    RECO_CSWMuon2MinusPhi = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuon2MinusPhi"</b></font><b></b>,<font color="#bc8f8f"><b>";RECO #mu^{-} #phi in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,700,-3.55,3.45);
    RECO_CSWMuon2PlusCosTheta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuon2PlusCosTheta"</b></font><b></b>,<font color="#bc8f8f"><b>";RECO #mu^{+} cos#theta in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,200,-1.05,0.95);
    RECO_CSWMuon2MinusCosTheta = <b><font color="#a020f0">new</font></b> TH1D(<font color="#bc8f8f"><b>"RECO_CSWMuon2MinusCosTheta"</b></font><b></b>,<font color="#bc8f8f"><b>";RECO #mu^{-} cos#theta in CS-Frame;Events / 10 pb^{-1}"</b></font><b></b>,200,-1.05,0.95);

    TH1::SetDefaultSumw2(kFALSE);
    MC_RECO_CSWMuonPhiCorrelation1 = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_RECO_CSWMuonPhiCorrelation1"</b></font><b></b>, <font color="#bc8f8f"><b>"; Reconstructed Muon #phi; True Muon #phi"</b></font><b></b>, 700,-3.55,3.45, 700,-3.55,3.45 );
    MC_RECO_CSWMuonPhiCorrelation2 = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_RECO_CSWMuonPhiCorrelation2"</b></font><b></b>, <font color="#bc8f8f"><b>"; Reconstructed Muon #phi; True Muon #phi"</b></font><b></b>, 700,-3.55,3.45, 700,-3.55,3.45 );
    MC_RECO_CSWMuonPhiCorrelation3 = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_RECO_CSWMuonPhiCorrelation3"</b></font><b></b>, <font color="#bc8f8f"><b>"; Reconstructed Muon #phi; True Muon #phi"</b></font><b></b>, 700,-3.55,3.45, 700,-3.55,3.45 );
    MC_RECO_CSWMuonPhiCorrelation4 = <b><font color="#a020f0">new</font></b> TH2D(<font color="#bc8f8f"><b>"MC_RECO_CSWMuonPhiCorrelation4"</b></font><b></b>, <font color="#bc8f8f"><b>"; Reconstructed Muon #phi; True Muon #phi"</b></font><b></b>, 700,-3.55,3.45, 700,-3.55,3.45 );

  }

  <font color="#228b22"><b>bool</b></font><b></b> RECOCSFramePlots::Process(Event::Data &amp; ev) {
    GenMatrixBin myGenMatrixBin(&amp;ev);
    <b><font color="#a020f0">if</font></b>(ev.LD_CommonMuons().accepted.size()==0) <b><font color="#a020f0">return</font></b> false;
    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenW.size()==0) <b><font color="#a020f0">return</font></b> false;

    vector &lt;Event::GenObject <font color="#228b22"><b>const</b></font><b></b> *&gt; theVBosons;
    theVBosons = myGenMatrixBin.the_GenW;
    <font color="#228b22"><b>double</b></font><b></b> w_pole_mass = 80.4;

    <i><font color="#b22222">//let us cheat and use the RECO muon, along with the generator W-boson that is defined in the same event
</font></i>    <i><font color="#b22222">//this will show us the effect of (essentially) the muon reconstruction
</font></i>    TLorentzVector lepton( CSTransform( TLVConvert(ev.LD_CommonMuons().accepted.at(0)), TLVConvert(theVBosons.at(0))) );

    <i><font color="#b22222">//so we need to make a choice for Pz and Mw to use in an event:
</font></i>    <i><font color="#b22222">//For Mw, let's try to use MtW if it's larger than the pole mass (80.4) otherwise use the pole mass
</font></i>    <i><font color="#b22222">//The transverse mass is defined with the pt of the neutrino and lepton
</font></i>    
    TLorentzVector reco_neutrino;
    TLorentzVector reco_muon( TLVConvert(ev.LD_CommonMuons().accepted.at(0)) );
    <i><font color="#b22222">//subtract the muon from the MHT (i.e. add it in) so that we have the transverse vector for the neutrino
</font></i>    <font color="#228b22"><b>double</b></font><b></b> reco_neutrino_Px = ev.CommonMHT().Px() - reco_muon.Px();
    <font color="#228b22"><b>double</b></font><b></b> reco_neutrino_Py = ev.CommonMHT().Py() - reco_muon.Py();
    reco_neutrino.SetXYZM(reco_neutrino_Px, reco_neutrino_Py, 0.0, 0.0);

    <i><font color="#b22222">//define the transverse mass of the W - which of course only uses transverse quantities
</font></i>    <font color="#228b22"><b>double</b></font><b></b> w_trans_mass = sqrt( 2.0*reco_muon.Pt()*reco_neutrino.Pt()*(1.0 - cos(reco_muon.DeltaPhi(reco_neutrino)) ) );
    RECO_CSWTransMass-&gt;Fill(w_trans_mass, ev.GetEventWeight());

    <b><font color="#a020f0">if</font></b>(myGenMatrixBin.the_GenMuon.size()) {
      TLorentzVector real_lepton( CSTransform( TLVConvert(myGenMatrixBin.the_GenMuon.at(0)), TLVConvert(theVBosons.at(0)) ) );
      MC_RECO_CSWMuonPhiCorrelation1-&gt;Fill(lepton.Phi(), real_lepton.Phi(), ev.GetEventWeight());

      TLorentzVector W_adjusted_mass;
      <i><font color="#b22222">//use the transverse mass if larger than the pole mass (otherwise pole mass)
</font></i>      <font color="#228b22"><b>double</b></font><b></b> adjusted_mass = w_pole_mass;
      <b><font color="#a020f0">if</font></b>(w_trans_mass &gt; w_pole_mass) adjusted_mass = w_trans_mass;
      W_adjusted_mass.SetXYZM(theVBosons.at(0)-&gt;Px(), theVBosons.at(0)-&gt;Py(), theVBosons.at(0)-&gt;Pz(), adjusted_mass);
      TLorentzVector lepton_adjWmass( CSTransform( TLVConvert(myGenMatrixBin.the_GenMuon.at(0)), W_adjusted_mass ) );
      MC_RECO_CSWMuonPhiCorrelation2-&gt;Fill(lepton_adjWmass.Phi(), real_lepton.Phi(), ev.GetEventWeight());


      <i><font color="#b22222">//if we want to do a full "reco"
</font></i>      <i><font color="#b22222">//work out the neutrino pz using the four-vector algebra. Do this first with the proper gen level W-boson mass
</font></i>      <i><font color="#b22222">//this is so we can check the effects of taking the positive and negative root have on phi - it should be independent...
</font></i>      <font color="#228b22"><b>double</b></font><b></b> constantA = (adjusted_mass*adjusted_mass) + (ev.CommonMHT().Perp2()) - (reco_muon.Perp2()) - (reco_neutrino.Perp2());
      <font color="#228b22"><b>double</b></font><b></b> constantB = (constantA * constantA) - (4.0 * (reco_muon.Perp2()) * (reco_neutrino.Perp2() ));
      <b><font color="#a020f0">if</font></b>(constantB &gt; 0) {
	<font color="#228b22"><b>double</b></font><b></b> constantC = (2.0 * reco_muon.Perp2()); <i><font color="#b22222">//paper says 4.0, i think 2.0 - let's see... it's 2.0! hehe
</font></i>	<font color="#228b22"><b>double</b></font><b></b> constantD = ((constantA * reco_muon.Pz()) / constantC);
	<font color="#228b22"><b>double</b></font><b></b> constantE = ((reco_muon.E() * sqrt(constantB)) / constantC);
	<i><font color="#b22222">//these solutions are the pz of the neutrino:
</font></i>	<font color="#228b22"><b>double</b></font><b></b> pzsol1 = (constantD + constantE);
	<font color="#228b22"><b>double</b></font><b></b> pzsol2 = (constantD - constantE);
	pzsol1 += reco_muon.Pz();
	pzsol2 += reco_muon.Pz();
	<i><font color="#b22222">//the "W-boson" we construct will have MHTX, MHTY, (pz_Neutrino + pz_Muon), Mass we choose - choice of pz solution shouldn't matter
</font></i>	TLorentzVector reco_wboson;
	reco_wboson.SetXYZM(ev.CommonMHT().Px(),ev.CommonMHT().Py(),pzsol1, adjusted_mass);
	TLorentzVector lepton_reco( CSTransform( reco_muon, reco_wboson ) );
	MC_RECO_CSWMuonPhiCorrelation3-&gt;Fill(lepton_reco.Phi(), real_lepton.Phi(), ev.GetEventWeight());
	<b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
	  RECO_CSWMuon2PlusPhi-&gt;Fill(lepton_reco.Phi(), ev.GetEventWeight());
	  RECO_CSWMuon2PlusCosTheta-&gt;Fill(lepton_reco.CosTheta(), ev.GetEventWeight());
	} <b><font color="#a020f0">else</font></b> { 
	  RECO_CSWMuon2MinusPhi-&gt;Fill(lepton_reco.Phi(), ev.GetEventWeight());
	  RECO_CSWMuon2MinusCosTheta-&gt;Fill(lepton_reco.CosTheta(), ev.GetEventWeight());
	}
      }

<i><font color="#b22222">/*NEEDS DEBUGGING
      //an alternative way to do the full reco is to solve directly for pzW from the four-vectors
      //start from PW=Pmu+Pnu then (Pw-Pmu)^2 = 0
      double constantF = ((adjusted_mass*adjusted_mass)/2.0) + (ev.CommonMHT().Px()*reco_muon.Px()) + (ev.CommonMHT().Py()*reco_muon.Py());
      double constantG = (constantF * constantF) + (reco_muon.Perp2()*(ev.CommonMHT().Perp2() + (adjusted_mass*adjusted_mass)) );
      if (constantG&gt;0) {
	double constantH = (reco_muon.E()*sqrt(constantG))/reco_muon.Perp2();
	double constantI = (constantF*reco_muon.Pz())/reco_muon.Perp2();
	TLorentzVector reco_wboson2;
	reco_wboson2.SetXYZM(ev.CommonMHT().Px(),ev.CommonMHT().Py(),(constantH+constantI), adjusted_mass);
	TLorentzVector lepton_reco2( CSTransform( reco_muon, reco_wboson2 ) );
	MC_RECO_CSWMuonPhiCorrelation4-&gt;Fill(lepton_reco2.Phi(), real_lepton.Phi(), ev.GetEventWeight());
      }
*/</font></i>
  }


    <font color="#228b22"><b>double</b></font><b></b> adjusted_phi=0.0;
    <i><font color="#b22222">//add 2Pi to the negative values of Phi to take it from [-pi,+pi] to [0,2pi]
</font></i>    <b><font color="#a020f0">if</font></b>(lepton.Phi() &lt; 0.0) adjusted_phi = ((2.0*TMath::Pi()) + lepton.Phi());
    <b><font color="#a020f0">else</font></b> adjusted_phi = lepton.Phi();

    <b><font color="#a020f0">if</font></b>(theVBosons.at(0)-&gt;GetID() &gt; 0) {
      RECO_CSWMuonPlusPhi-&gt;Fill(lepton.Phi(), ev.GetEventWeight());
      RECO_CSWMuonPlusPhi2-&gt;Fill(adjusted_phi, ev.GetEventWeight());
      RECO_CSWMuonPlusCosTheta-&gt;Fill(lepton.CosTheta(), ev.GetEventWeight());
    } <b><font color="#a020f0">else</font></b> { 
      RECO_CSWMuonMinusPhi-&gt;Fill(lepton.Phi(), ev.GetEventWeight());
      RECO_CSWMuonMinusPhi2-&gt;Fill(adjusted_phi, ev.GetEventWeight());
      RECO_CSWMuonMinusCosTheta-&gt;Fill(lepton.CosTheta(), ev.GetEventWeight());
    }


    <b><font color="#a020f0">return</font></b> true;
  }

  std::ostream&amp; RECOCSFramePlots::Description(std::ostream &amp;ostrm) {
    ostrm &lt;&lt; <font color="#bc8f8f"><b>"RECO Collins-Soper Frame Plots"</b></font><b></b>;
    <b><font color="#a020f0">return</font></b> ostrm;
  }

} <i><font color="#b22222">//~namespace Operation
</font></i></pre>
</pre></div>

<hr>
<table>
<tbody><tr>
<td><address><a href="http://lcgcvs.web.cern.ch/lcgcvs">CERN LCG CVS service</a></address></td>
<td style="text-align: right;"><strong><a href="http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/*docroot*/help_rootview.html">ViewVC Help</a></strong></td>
</tr>
<tr>
<td>Powered by <a href="http://viewvc.tigris.org/">ViewVC 1.0.4</a></td>
<td style="text-align: right;">&nbsp;</td>
</tr>
</tbody></table>
</body></html>